<?xml version="1.0" encoding="iso-8859-1"?>
<acldoc acl_id="P04-1043">
	

	<s id="1">
		 A Study on Convolution Kernels for Shallow Semantic Parsing Alessandro Moschitti University of Texas at Dallas Human Language Technology Research Institute Richardson , TX 75083-0688 , USA alessandro.moschitti@utdallas.edu Abstract In this paper we have designed and experimented novel convolution kernels for automatic classification of predicate arguments . 
	</s>
	

	<s id="2">
		 Their main property is the ability to process structured representations . 
	</s>
	

	<s id="3">
		 Support Vector Machines ( SVMs ) , using a combination of such kernels and the flat feature kernel , classify Prop- Bank predicate arguments with accuracy higher than the current argument classification state- of-the-art . 
	</s>
	

	<s id="4">
		 Additionally , experiments on FrameNet data have shown that SVMs are appealing for the classification of semantic roles even if the proposed kernels do not produce any improvement . 
	</s>
	

	<s id="5">
		 1 Introduction Several linguistic theories , e.g. 
		<ref citStr="Jackendoff , 1990" id="1" label="CEPF" position="952">
			( Jackendoff , 1990 )
		</ref>
		 claim that semantic information in natural language texts is connected to syntactic structures . 
	</s>
	

	<s id="6">
		 Hence , to deal with natural language semantics , the learning algorithm should be able to represent and process structured data . 
	</s>
	

	<s id="7">
		 The classical solution adopted for such tasks is to convert syntax structures into flat feature representations which are suitable for a given learning model . 
	</s>
	

	<s id="8">
		 The main drawback is that structures may not be properly represented by flat features . 
	</s>
	

	<s id="9">
		 In particular , these problems affect the processing of predicate argument structures annotated in PropBank 
		<ref citStr="Kingsbury and Palmer , 2002" id="2" label="OEPN" position="1604">
			( Kingsbury and Palmer , 2002 )
		</ref>
		 or FrameNet 
		<ref citStr="Fillmore , 1982" id="3" label="OEPF" position="1636">
			( Fillmore , 1982 )
		</ref>
		 . 
	</s>
	

	<s id="10">
		 Figure 1 shows an example of a predicate annotation in PropBank for the sentence : &quot; Paul gives a lecture in Rome &quot; . 
	</s>
	

	<s id="11">
		 A predicate may be a verb or a noun or an adjective and most of the time Arg 0 is the logical subject , Arg 1 is the logical object and ArgM may indicate locations , as in our example . 
	</s>
	

	<s id="12">
		 FrameNet also describes predicate/argument structures but for this purpose it uses richer semantic structures called frames . 
	</s>
	

	<s id="13">
		 These latter are schematic representations of situations involving various participants , properties and roles in which a word may be typically used . 
	</s>
	

	<s id="14">
		 Frame elements or semantic roles are arguments of predicates called target words . 
	</s>
	

	<s id="15">
		 In FrameNet , the argument names are local to a particular frame . 
	</s>
	

	<s id="16">
		 Figure 1 : A predicate argument structure in a parse-tree representation . 
	</s>
	

	<s id="17">
		 Several machine learning approaches for argument identification and classification have been developed 
		<ref citStr="Gildea and Jurasfky , 2002" id="4" label="CJPF" position="2620">
			( Gildea and Jurasfky , 2002 
		</ref>
		<ref citStr="Gildea and Palmer , 2002" id="5" label="CJPF" position="2649">
			; Gildea and Palmer , 2002 
		</ref>
		<ref citStr="Surdeanu et al. , 2003" id="6" label="CJPN" position="2676">
			; Surdeanu et al. , 2003 
		</ref>
		<ref citStr="Hacioglu et al. , 2003" id="7" label="CJPF" position="2701">
			; Hacioglu et al. , 2003 )
		</ref>
		 . 
	</s>
	

	<s id="18">
		 Their common characteristic is the adoption of feature spaces that model predicate-argument structures in a flat representation . 
	</s>
	

	<s id="19">
		 On the contrary , convolution kernels aim to capture structural information in term of sub-structures , providing a viable alternative to flat features . 
	</s>
	

	<s id="20">
		 In this paper , we select portions of syntactic trees , which include predicate/argument salient sub-structures , to define convolution kernels for the task of predicate argument classification . 
	</s>
	

	<s id="21">
		 In particular , our kernels aim to ( a ) represent the relation between predicate and one of its arguments and ( b ) to capture the overall argument structure of the target predicate . 
	</s>
	

	<s id="22">
		 Additionally , we define novel kernels as combinations of the above two with the polynomial kernel of standard flat features . 
	</s>
	

	<s id="23">
		 Experiments on Support Vector Machines using the above kernels show an improvement N VP V Paul PP NP Arg . 
	</s>
	

	<s id="24">
		 0 gives Predicate IN N D N Arg . 
	</s>
	

	<s id="25">
		 1 Arg . 
	</s>
	

	<s id="26">
		 M S in a lecture Rome of the state-of-the-art for PropBank argument classification . 
	</s>
	

	<s id="27">
		 On the contrary , FrameNet semantic parsing seems to not take advantage of the structural information provided by our kernels . 
	</s>
	

	<s id="28">
		 The remainder of this paper is organized as follows : Section 2 defines the Predicate Argument Extraction problem and the standard solution to solve it . 
	</s>
	

	<s id="29">
		 In Section 3 we present our kernels whereas in Section 4 we show comparative results among SVMs using standard features and the proposed kernels . 
	</s>
	

	<s id="30">
		 Finally , Section 5 summarizes the conclusions . 
	</s>
	

	<s id="31">
		 2 Predicate Argument Extraction : a standard approach Given a sentence in natural language and the target predicates , all arguments have to be recognized . 
	</s>
	

	<s id="32">
		 This problem can be divided into two subtasks : ( a ) the detection of the argument boundaries , i.e. all its compounding words and ( b ) the classification of the argument type , e.g. Arg0 or ArgM in PropBank or Agent and Goal in FrameNet . 
	</s>
	

	<s id="33">
		 The standard approach to learn both detection and classification of predicate arguments is summarized by the following steps : 1 . 
	</s>
	

	<s id="34">
		 Given a sentence from the training-set generate a full syntactic parse-tree ; 2. let P and A be the set of predicates and the set of parse-tree nodes ( i.e. the potential arguments ) , respectively ; 3. for each pair &lt;p , a&gt; E P x A : • extract the feature representation set , Fp,a ; • if the subtree rooted in a covers exactly the words of one argument of p , put Fp,a in T+ ( positive examples ) , otherwise put it in T— ( negative examples ) . 
	</s>
	

	<s id="35">
		 For example , in Figure 1 , for each combination of the predicate give with the nodes N , S , VP , V , NP , PP , D or IN the instances F”give”,a are generated . 
	</s>
	

	<s id="36">
		 In case the node a exactly covers Paul , a lecture or in Rome , it will be a positive instance otherwise it will be a negative one , e.g. F”give”,” IN” . 
	</s>
	

	<s id="37">
		 To learn the argument classifiers the T+ set can be re-organized as positive T +argi and negative T—argi examples for each argument i . 
	</s>
	

	<s id="38">
		 In this way , an individual ONE-vs-ALL classifier for each argument i can be trained . 
	</s>
	

	<s id="39">
		 We adopted this solution as it is simple and effective 
		<ref citStr="Hacioglu et al. , 2003" id="8" label="CEPF" position="6044">
			( Hacioglu et al. , 2003 )
		</ref>
		 . 
	</s>
	

	<s id="40">
		 In the classification phase , given a sentence of the test-set , all its Fp a are generated and classified by each individ- argument associated with the maximum value among the scores provided by the SVMs , i.e. argmaxiES Ci , where S is the target set of arguments . 
	</s>
	

	<s id="41">
		 - Phrase Type : This feature indicates the syntactic type of the phrase labeled as a predicate argument , e.g. NP for Arg1 . 
	</s>
	

	<s id="42">
		 - Parse Tree Path : This feature contains the path in the parse tree between the predicate and the argument phrase , expressed as a sequence of nonterminal labels linked by direction ( up or down ) symbols , e.g. V I VP J NP for Arg1 . 
	</s>
	

	<s id="43">
		 - Position : Indicates if the constituent , i.e. the potential argument , appears before or after the predicate in the sentence , e.g. after for Arg1 and before for Arg0 . 
	</s>
	

	<s id="44">
		 - Voice : This feature distinguishes between active or passive voice for the predicate phrase , e.g. active for every argument . 
	</s>
	

	<s id="45">
		 - Head Word : This feature contains the headword of the evaluated phrase . 
	</s>
	

	<s id="46">
		 Case and morphological information are preserved , e.g. lecture for Arg1 . 
	</s>
	

	<s id="47">
		 - Governing Category indicates if an NP is dominated by a sentence phrase or by a verb phrase , e.g. the NP associated with Arg1 is dominated by a VP . 
	</s>
	

	<s id="48">
		 ual classifier . 
	</s>
	

	<s id="49">
		 As a final decision , we select the - Predicate Word : This feature consists of two components : ( 1 ) the word itself , e.g. gives for all arguments ; and ( 2 ) the lemma which represents the verb normalized to lower case and infinitive form , e.g. give for all arguments . 
	</s>
	

	<s id="50">
		 Table 1 : Standard features extracted from the parse-tree in Figure 1. 2.1 Standard feature space The discovery of relevant features is , as usual , a complex task , nevertheless , there is a common consensus on the basic features that should be adopted . 
	</s>
	

	<s id="51">
		 These standard features , firstly proposed in 
		<ref citStr="Gildea and Jurasfky , 2002" id="9" label="CERF" position="8011">
			( Gildea and Jurasfky , 2002 )
		</ref>
		 , refer to a flat information derived from parse trees , i.e. Phrase Type , Predicate Word , Head Word , Governing Category , Position and Voice . 
	</s>
	

	<s id="52">
		 Table 1 presents the standard features and exemplifies how they are extracted from the parse tree in Figure 1 . 
	</s>
	

	<s id="53">
		 For example , the Parse Tree Path feature represents the path in the parse-tree between a predicate node and one of its argument nodes . 
	</s>
	

	<s id="54">
		 It is expressed as a sequence of nonterminal labels linked by direction symbols ( up or down ) , e.g. in Figure 1 , VTVPINP is the path between the predicate to give and the argument 1 , a lecture . 
	</s>
	

	<s id="55">
		 Two pairs &lt;p1 , a1&gt; and &lt;p2 , a2&gt; have two different Path features even if the paths differ only for a node in the parse-tree . 
	</s>
	

	<s id="56">
		 This pre- Figure 2 : Structured features for Arg0 , Arg1 and ArgM . 
	</s>
	

	<s id="57">
		 jj a talk in N a ) S Fdeliver , Arg0 b ) S Fdeliver , Arg1 c ) S 0 Arg . 
	</s>
	

	<s id="58">
		 N Paul V delivers D N NP VP IN NP PP Paul N delivers V D N IN NP a Arg . 
	</s>
	

	<s id="59">
		 1 NP VP talk in PP jj N Paul N delivers V D N a talk NP VP PP IN NP in jj N formal style Fdeliver , ArgM style formal style formal Arg . 
	</s>
	

	<s id="60">
		 M vents the learning algorithm to generalize well on unseen data . 
	</s>
	

	<s id="61">
		 In order to address this problem , the next section describes a novel kernel space for predicate argument classification . 
	</s>
	

	<s id="62">
		 2.2 Support Vector Machine approach Given a vector space in Rn and a set of positive and negative points , SVMs classify vectors according to a separating hyperplane , H(~x) = w~ x x~+ b= 0 , where w~ E Rn and b E Rare learned by applying the Structural Risk Minimization principle 
		<ref citStr="Vapnik , 1995" id="10" label="CEPF" position="9686">
			( Vapnik , 1995 )
		</ref>
		 . 
	</s>
	

	<s id="63">
		 To apply the SVM algorithm to Predicate Argument Classification , we need a function O : F — , Rn to map our features space F = { f1 , .. , f|F| } and our predicate/argument pair representation,( Fp a =(O1 Fz , into Rn , such that : Fz — O(Fz) = ( Fz ) , .. , On ( Fz ) ) From the kernel theory we have that : H(x) = ( E aixi ) • x + b = E ai~xi•~x+b= i=1..l i=1..l = aiO(Fi) • O(Fz) + b. i=1..l where , Fi Vi E { 1 , .. , l } are the training instances and the product K(Fi , Fz ) =&lt;O(Fi) • O(Fz)&gt; is the kernel function associated with the mapping O . 
	</s>
	

	<s id="64">
		 The simplest mapping that we can apply is O(Fz) = z~ = ( z1 , ... , zn ) where zi = 1 if fi E Fz otherwise zi = 0 , i.e. the characteristic vector of the set Fz with respect to F . 
	</s>
	

	<s id="65">
		 If we choose as a kernel function the scalar product we obtain the linear kernel KL(Fx , Fz ) =x~•~z . 
	</s>
	

	<s id="66">
		 Another function which is the current state- of-the-art of predicate argument classification is the polynomial kernel : Kp(Fx , Fz ) = ( c+~x •~z)d , where c is a constant and d is the degree of the polynom . 
	</s>
	

	<s id="67">
		 3 Convolution Kernels for Semantic Parsing We propose two different convolution kernels associated with two different predicate argu- ment sub-structures : the first includes the target predicate with one of its arguments . 
	</s>
	

	<s id="68">
		 We will show that it contains almost all the standard feature information . 
	</s>
	

	<s id="69">
		 The second relates to the sub-categorization frame of verbs . 
	</s>
	

	<s id="70">
		 In this case , the kernel function aims to cluster together verbal predicates which have the same syntactic realizations . 
	</s>
	

	<s id="71">
		 This provides the classification algorithm with important clues about the possible set of arguments suited for the target syntactic structure . 
	</s>
	

	<s id="72">
		 3.1 Predicate/Argument Feature ( PAF ) We consider the predicate argument structures annotated in PropBank or FrameNet as our semantic space . 
	</s>
	

	<s id="73">
		 The smallest sub-structure which includes one predicate with only one of its arguments defines our structural feature . 
	</s>
	

	<s id="74">
		 For example , Figure 2 illustrates the parse-tree of the sentence &quot; Paul delivers a talk in formal style &quot; . 
	</s>
	

	<s id="75">
		 The circled substructures in ( a ) , ( b ) and ( c ) are our semantic objects associated with the three arguments of the verb to deliver , i.e. &lt;deliver , Arg0&gt; , &lt;deliver , Arg1 &gt; and &lt;deliver , ArgM&gt; . 
	</s>
	

	<s id="76">
		 Note that each predicate/argument pair is associated with only one structure , i.e. Fp,a contain only one of the circled sub-trees . 
	</s>
	

	<s id="77">
		 Other important properties are the followings : ( 1 ) The overall semantic feature space F contains sub-structures composed of syntactic information embodied by parse-tree dependencies and semantic information under the form of predicate/argument annotation . 
	</s>
	

	<s id="78">
		 ( 2 ) This solution is efficient as we have to classify as many nodes as the number of predicate arguments . 
	</s>
	

	<s id="79">
		 ( 3 ) A constituent cannot be part of two different arguments of the target predicate , i.e. there is no overlapping between the words of two arguments . 
	</s>
	

	<s id="80">
		 Thus , two semantic structures Fp1,a1 and Fp2,a21 , associated with two different ar- 1Fp,a was defined as the set of features of the object &lt;p , a&gt; . 
	</s>
	

	<s id="81">
		 Since in our representations we have only one Figure 4 : All 17 valid fragments of the semantic structure associated with Arg 1 of Figure 2. F~ = ~f'1 , .. , f ' IF'I~ and ( 2 ) from F~ to RIF'I . 
	</s>
	

	<s id="82">
		 An example of features in F~ is given in Figure 4 where the whole set of fragments , F~deliver,Ary1 , of the argument structure Fdeliver,Ary1 , is shown ( see also Figure 2 ) . 
	</s>
	

	<s id="83">
		 It is worth noting that the allowed sub-trees contain the entire ( not partial ) production rules . 
	</s>
	

	<s id="84">
		 For instance , the sub-tree [ NP [ D a ] ] is excluded from the set of the Figure 4 since only a part of the production NP —* D N is used in its generation . 
	</s>
	

	<s id="85">
		 However , this constraint does not apply to the production VP —* V NP PP along with the fragment [ VP [ V NP ] ] as the subtree [ VP [ PP [ ... ] ] ] is not considered part of the semantic structure . 
	</s>
	

	<s id="86">
		 Thus , in step 1 , an argument structure Fp,a is mapped in a fragment set F~p,a . 
	</s>
	

	<s id="87">
		 In step 2 , this latter is mapped into x~ = ( x1,..,xIF'I ) E RIF'I , where xi is equal to the number of times that f'i occurs in F~p,a2 . 
	</s>
	

	<s id="88">
		 In order to evaluate K(O(Fx) , O(Fz)) without evaluating the feature vector x~ and z~ we define the indicator function Ii ( n ) = 1 if the substructure i is rooted at node n and 0 otherwise . 
	</s>
	

	<s id="89">
		 It follows that Oi(Fx) = ~nENx Ii(n) , where Nx is the set of the Fx’s nodes . 
	</s>
	

	<s id="90">
		 Therefore , the kernel can be written as : IF'1 K(O(Fx) , ~(Fz)) = E ( E Ii(nx))( E Ii(nz)) i=1 nxENx nz ENz E= E E Ii (nx)Ii ( nz ) nxENx nz ENz i where Nx and Nz are the nodes in Fx and Fz , respectively . 
	</s>
	

	<s id="91">
		 In 
		<ref citStr="Collins and Duffy , 2002" id="11" label="CEPF" position="14614">
			( Collins and Duffy , 2002 )
		</ref>
		 , it has been shown that ~i Ii(nx)Ii(nz) = A(nx , nz ) can be computed in O(JNxJ x INzI ) by the following recursive relation : ( 1 ) if the productions at nx and nz are different then A(nx , nz ) = 0 ; 2A fragment can appear several times in a parse-tree , thus each fragment occurrence is considered as a different element in F'v,a . 
	</s>
	

	<s id="92">
		 Fflush Fbuckle S NPArg1 VP ( flush ) Arg1 ( buckle ) Arg0 ( flush and buckle ) PRP VP CC VP He and VBD NP buckled PRP $ NN VBD NP flushed DT NN the pan his belt Figure 3 : Sub-Categorization Features for two predicate argument structures . 
	</s>
	

	<s id="93">
		 guments , cannot be included one in the other . 
	</s>
	

	<s id="94">
		 This property is important because a convolution kernel would not be effective to distinguish between an object and its sub-parts . 
	</s>
	

	<s id="95">
		 3.2 Sub-Categorization Feature ( SCF ) The above object space aims to capture all the information between a predicate and one of its arguments . 
	</s>
	

	<s id="96">
		 Its main drawback is that important structural information related to inter- argument dependencies is neglected . 
	</s>
	

	<s id="97">
		 In order to solve this problem we define the Sub- Categorization Feature ( SCF ) . 
	</s>
	

	<s id="98">
		 This is the sub- parse tree which includes the sub-categorization frame of the target verbal predicate . 
	</s>
	

	<s id="99">
		 For example , Figure 3 shows the parse tree of the sentence &quot; He flushed the pan and buckled his belt &quot; . 
	</s>
	

	<s id="100">
		 The solid line describes the SCF of the predicate flush , i.e. Fflush whereas the dashed line tailors the SCF of the predicate buckle , i.e. Fbuckle . 
	</s>
	

	<s id="101">
		 Note that SCFs are features for predicates , ( i.e. they describe predicates ) whereas PAF characterizes predicate/argument pairs . 
	</s>
	

	<s id="102">
		 Once semantic representations are defined , we need to design a kernel function to estimate the similarity between our objects . 
	</s>
	

	<s id="103">
		 As suggested in Section 2 we can map them into vectors in Rn and evaluate implicitly the scalar product among them . 
	</s>
	

	<s id="104">
		 3.3 Predicate/Argument structure Kernel ( PAK ) Given the semantic objects defined in the previous section , we design a convolution kernel in a way similar to the parse-tree kernel proposed in 
		<ref citStr="Collins and Duffy , 2002" id="12" label="OEPF" position="16792">
			( Collins and Duffy , 2002 )
		</ref>
		 . 
	</s>
	

	<s id="105">
		 We divide our mapping 0 in two steps : ( 1 ) from the semantic structure space F ( i.e. PAF or SCF objects ) to the set of all their possible sub-structures element in Fv,a with an abuse of notation we use it to indicate the objects themselves . 
	</s>
	

	<s id="106">
		 Predicate 1 Predicate 2 VP VP VP V D N D N D N NP NP NP V V a talk a talk a talk VP D N delivers VP VP VP VP VP VP NP NP NP D N a talk a talk a D N talk D N D N D N a talk V NP V D N V delivers NP D N NP NP V NP V NP V NP V delivers D N delivers D N delivers NP V delivers ( 2 ) if the productions at n , , and nz are the same , and n , , and nz are pre-terminals then 0(n , , , nz ) = 1 ; ( 3 ) if the productions at n , , and nz are the same , and n , , and nz are not pre-terminals then nc(nx) ~(n , , , nz ) = H ( 1 + ~(ch(n , , , j ) , ch(nz , j ) ) ) , j=1 where nc(n,,) is the number of the children of n , , and ch(n , i ) is the i-th child of the node n . 
	</s>
	

	<s id="107">
		 Note that as the productions are the same ch(n , , , i ) = ch(nz , i ) . 
	</s>
	

	<s id="108">
		 This kind of kernel has the drawback of assigning more weight to larger structures while the argument type does not strictly depend on the size of the argument 
		<ref citStr="Moschitti and Bejan , 2004" id="13" label="CEPF" position="18005">
			( Moschitti and Bejan , 2004 )
		</ref>
		 . 
	</s>
	

	<s id="109">
		 To overcome this problem we can scale the relative importance of the tree fragments using a parameter A for the cases ( 2 ) and ( 3 ) , i.e. ~(n , , , nz ) = A and ~(n , , , nz ) = A jl ; c(i , ) ( 1 + ~(ch(n , , , j ) , ch(nz , j ) ) ) respectively . 
	</s>
	

	<s id="110">
		 It is worth noting that even if the above equations define a kernel function similar to the one proposed in 
		<ref citStr="Collins and Duffy , 2002" id="14" label="CEPF" position="18414">
			( Collins and Duffy , 2002 )
		</ref>
		 , the substructures on which it operates are different from the parse-tree kernel . 
	</s>
	

	<s id="111">
		 For example , Figure 4 shows that structures such as [ VP [ V ] [ NP ] ] , [ VP [ V delivers ] [ NP ] ] and [ VP [ V ] [ NP [ DT ] [ N ] ] ] are valid features , but these fragments ( and many others ) are not generated by a complete production , i.e. VP —* V NP PP . 
	</s>
	

	<s id="112">
		 As a consequence they would not be included in the parse-tree kernel of the sentence . 
	</s>
	

	<s id="113">
		 3.4 Comparison with Standard Features In this section we compare standard features with the kernel based representation in order to derive useful indications for their use : First , PAK estimates a similarity between two argument structures ( i.e. , PAF or SCF ) by counting the number of sub-structures that are in common . 
	</s>
	

	<s id="114">
		 As an example , the similarity between the two structures in Figure 2 , F”delivers”,Arg0 and F”delivers”,Arg1 , is equal to 1 since they have in common only the [ V delivers ] substructure . 
	</s>
	

	<s id="115">
		 Such low value depends on the fact that different arguments tend to appear in different structures . 
	</s>
	

	<s id="116">
		 On the contrary , if two structures differ only for a few nodes ( especially terminals or near terminal nodes ) the similarity remains quite high . 
	</s>
	

	<s id="117">
		 For example , if we change the tense of the verb to deliver ( Figure 2 ) in delivered , the [ VP [ V delivers ] [ NP ] ] subtree will be transformed in [ VP [ VBD delivered ] [ NP ] ] , where the NP is unchanged . 
	</s>
	

	<s id="118">
		 Thus , the similarity with the previous structure will be quite high as : ( 1 ) the NP with all sub-parts will be matched and ( 2 ) the small difference will not highly affect the kernel norm and consequently the final score . 
	</s>
	

	<s id="119">
		 The above property also holds for the SCF structures . 
	</s>
	

	<s id="120">
		 For example , in Figure 3 , KPAK ( 0(Ffl.sh) , 0(Fb.ckle)) is quite high as the two verbs have the same syntactic realization of their arguments . 
	</s>
	

	<s id="121">
		 In general , flat features do not possess this conservative property . 
	</s>
	

	<s id="122">
		 For example , the Parse Tree Path is very sensible to small changes of parse-trees , e.g. two predicates , expressed in different tenses , generate two different Path features . 
	</s>
	

	<s id="123">
		 Second , some information contained in the standard features is embedded in PAF : Phrase Type , Predicate Word and Head Word explicitly appear as structure fragments . 
	</s>
	

	<s id="124">
		 For example , in Figure 4 are shown fragments like [ NP [ DT ] [ N ] ] or [ NP [ DT a ] [ N talk ] ] which explicitly encode the Phrase Type feature NP for the Arg 1 in Figure 2.b. . 
	</s>
	

	<s id="125">
		 The Predicate Word is represented by the fragment [ V delivers ] and the Head Word is encoded in [ N talk ] . 
	</s>
	

	<s id="126">
		 The same is not true for SCF since it does not contain information about a specific argument . 
	</s>
	

	<s id="127">
		 SCF , in fact , aims to characterize the predicate with respect to the overall argument structures rather than a specific pair &lt;p , a&gt; . 
	</s>
	

	<s id="128">
		 Third , Governing Category , Position and Voice features are not explicitly contained in both PAF and SCF . 
	</s>
	

	<s id="129">
		 Nevertheless , SCF may allow the learning algorithm to detect the active/passive form of verbs . 
	</s>
	

	<s id="130">
		 Finally , from the above observations follows that the PAF representation may be used with PAK to classify arguments . 
	</s>
	

	<s id="131">
		 On the contrary , SCF lacks important information , thus , alone it may be used only to classify verbs in syntactic categories . 
	</s>
	

	<s id="132">
		 This suggests that SCF should be used in conjunction with standard features to boost their classification performance . 
	</s>
	

	<s id="133">
		 4 The Experiments The aim of our experiments are twofold : On the one hand , we study if the PAF representation produces an accuracy higher than standard features . 
	</s>
	

	<s id="134">
		 On the other hand , we study if SCF can be used to classify verbs according to their syntactic realization . 
	</s>
	

	<s id="135">
		 Both the above aims can be carried out by combining PAF and SCF with the standard features . 
	</s>
	

	<s id="136">
		 For this purpose we adopted two ways to combine kernels3 : ( 1 ) K = K1 · K2 and ( 2 ) K = -yK1 + K2 . 
	</s>
	

	<s id="137">
		 The resulting set of kernels used in the experiments is the following : • Kpd is the polynomial kernel with degree d over the standard features . 
	</s>
	

	<s id="138">
		 • KPAF is obtained by using PAK function over the PAF structures . 
	</s>
	

	<s id="139">
		 •~v K KPAF+P = lIKPAFI+IKp d dI,i.e. the sum be- tween the normalized4 PAF-based kernel and the normalized polynomial kernel . 
	</s>
	

	<s id="140">
		 KPAF•Kpd •KPAF.P =IKPAF I • I Kpd I , i.e. the normalized product between the PAF-based kernel and the polynomial kernel . 
	</s>
	

	<s id="141">
		 •K KSCF KSCF+P=-yIKSCFI + IK dI,i.e. the summa- tion between the normalized SCF-based kernel and the normalized polynomial kernel . 
	</s>
	

	<s id="142">
		 KSCF•Kpd KSCFI•IKpdI , i.e. the normal- I ized product between SCF-based kernel and the polynomial kernel . 
	</s>
	

	<s id="143">
		 4.1 Corpora set-up The above kernels were experimented over two corpora : PropBank ( www.cis.upenn.edu/—ace ) along with Penn TreeBank5 2 
		<ref citStr="Marcus et al. , 1993" id="15" label="OEPF" position="23431">
			( Marcus et al. , 1993 )
		</ref>
		 and FrameNet . 
	</s>
	

	<s id="144">
		 PropBank contains about 53,700 sentences and a fixed split between training and testing which has been used in other researches e.g. , 
		<ref citStr="Gildea and Palmer , 2002" id="16" label="CEPF" position="23591">
			( Gildea and Palmer , 2002 
		</ref>
		<ref citStr="Surdeanu et al. , 2003" id="17" label="CEPF" position="23618">
			; Surdeanu et al. , 2003 
		</ref>
		<ref citStr="Hacioglu et al. , 2003" id="18" label="CEPF" position="23643">
			; Hacioglu et al. , 2003 )
		</ref>
		 . 
	</s>
	

	<s id="145">
		 In this split , Sections from 02 to 21 are used for training , section 23 for testing and sections 1 and 22 as developing set . 
	</s>
	

	<s id="146">
		 We considered all PropBank arguments6 from Arg0 to Arg9 , ArgA and ArgM for a total of 122,774 and 7,359 arguments in training and testing respectively . 
	</s>
	

	<s id="147">
		 It is worth noting that in the experiments we used the gold standard parsing from Penn TreeBank , thus our kernel structures are derived with high precision . 
	</s>
	

	<s id="148">
		 For the FrameNet corpus ( www. icsi . 
	</s>
	

	<s id="149">
		 berkeley 3It can be proven that the resulting kernels still satisfy Mercer’s conditions 
		<ref citStr="Cristianini and Shawe-Taylor , 2000" id="19" label="CEPF" position="24324">
			( Cristianini and Shawe-Taylor , 2000 )
		</ref>
		 . 
	</s>
	

	<s id="150">
		 4To normalize a kernel K(-x , z- ) we can divide it by IK(-x , -x ) - K(-z , z- ) . 
	</s>
	

	<s id="151">
		 5We point out that we removed from Penn TreeBank the function tags like SBJ and TMP as parsers usually are not able to provide this information . 
	</s>
	

	<s id="152">
		 6We noted that only Arg0 to Arg4 and ArgM contain enough training/testing data to affect the overall performance . 
	</s>
	

	<s id="153">
		 .edu/—framenet ) we extracted all 24,558 sen tences from the 40 frames of Senseval 3 task ( www. senseval . 
	</s>
	

	<s id="154">
		 org ) for the Automatic Labeling of Semantic Roles . 
	</s>
	

	<s id="155">
		 We considered 18 of the most frequent roles and we mapped together those having the same name . 
	</s>
	

	<s id="156">
		 Only verbs are se- lected to be predicates in our evaluations . 
	</s>
	

	<s id="157">
		 More- over , as it does not exist a fixed split between training and testing , we selected randomly 30 % of sentences for testing and 70 % for training . 
	</s>
	

	<s id="158">
		 Additionally , 30 % of training was used as a validation-set . 
	</s>
	

	<s id="159">
		 The sentences were processed us- ing Collins’ parser 
		<ref citStr="Collins , 1997" id="20" label="OEPF" position="25373">
			( Collins , 1997 )
		</ref>
		 to generate parse-trees automatically . 
	</s>
	

	<s id="160">
		 4.2 Classification set-up The classifier evaluations were carried out using the SVM-light software 
		<ref citStr="Joachims , 1999" id="21" label="OEPF" position="25541">
			( Joachims , 1999 )
		</ref>
		 available at svmlight.joachims.org with the default polynomial kernel for standard feature evaluations . 
	</s>
	

	<s id="161">
		 To process PAF and SCF , we implemented our own kernels and we used them inside SVM-light . 
	</s>
	

	<s id="162">
		 The classification performances were evaluated using the f1 measure7 for single arguments and the accuracy for the final multi-class classifier . 
	</s>
	

	<s id="163">
		 This latter choice allows us to compare the results with previous literature works , e.g. 
		<ref citStr="Gildea and Jurasfky , 2002" id="22" label="CJPF" position="26002">
			( Gildea and Jurasfky , 2002 
		</ref>
		<ref citStr="Surdeanu et al. , 2003" id="23" label="CJPF" position="26031">
			; Surdeanu et al. , 2003 
		</ref>
		<ref citStr="Hacioglu et al. , 2003" id="24" label="CJPF" position="26056">
			; Hacioglu et al. , 2003 )
		</ref>
		 . 
	</s>
	

	<s id="164">
		 For the evaluation of SVMs , we used the default regularization parameter ( e.g. , C = 1 for normalized kernels ) and we tried a few cost- factor values ( i.e. , j E { 0.1,1 , 2 , 3 , 4 , 5 } ) to adjust the rate between Precision and Recall . 
	</s>
	

	<s id="165">
		 We chose parameters by evaluating SVM using Kp3 kernel over the validation-set . 
	</s>
	

	<s id="166">
		 Both A ( see Section 3.3 ) and -y parameters were evaluated in a similar way by maximizing the performance of SVM using KPAF and -y KSCF IKSCFI +IKPdIrespec- tively . 
	</s>
	

	<s id="167">
		 These parameters were adopted also for all the other kernels . 
	</s>
	

	<s id="168">
		 4.3 Kernel evaluations To study the impact of our structural kernels we firstly derived the maximal accuracy reachable with standard features along with polynomial kernels . 
	</s>
	

	<s id="169">
		 The multi-class accuracies , for Prop- Bank and FrameNet using Kpd with d = 1 , .. , 5 , are shown in Figure 5 . 
	</s>
	

	<s id="170">
		 We note that ( a ) the highest performance is reached for d = 3 , ( b ) for PropBank our maximal accuracy ( 90.5 % ) 7 f 1 assigns equal importance to Precision P and Recall R i.e. f1 2P•R = P+R . 
	</s>
	

	<s id="171">
		 •KSCF•P = is substantially equal to the SVM performance ( 88 % ) obtained in 
		<ref citStr="Hacioglu et al. , 2003" id="25" label="CJPF" position="27302">
			( Hacioglu et al. , 2003 )
		</ref>
		 with degree 2 and ( c ) the accuracy on FrameNet ( 85.2 % ) is higher than the best result obtained in literature , i.e. 82.0 % in 
		<ref citStr="Gildea and Palmer , 2002" id="26" label="CEPF" position="27462">
			( Gildea and Palmer , 2002 )
		</ref>
		 . 
	</s>
	

	<s id="172">
		 This different outcome is due to a different task ( we classify different roles ) and a different classification algorithm . 
	</s>
	

	<s id="173">
		 Moreover , we did not use the Frame information which is very important $. 1 2 d 3 4 5 Figure 5 : Multi-classifier accuracy according to different degrees of the polynomial kernel . 
	</s>
	

	<s id="174">
		 It is worth noting that the difference between linear and polynomial kernel is about 3-4 percent points for both PropBank and FrameNet . 
	</s>
	

	<s id="175">
		 This remarkable difference can be easily explained by considering the meaning of standard features . 
	</s>
	

	<s id="176">
		 For example , let us restrict the classification function CArg0 to the two features Voice and Position . 
	</s>
	

	<s id="177">
		 Without loss of generality we can assume : ( a ) Voice=1 if active and 0 if passive , and ( b ) Position=1 when the argument is after the predicate and 0 otherwise . 
	</s>
	

	<s id="178">
		 To simplify the example , we also assume that if an argument precedes the target predicate it is a subject , otherwise it is an objects . 
	</s>
	

	<s id="179">
		 It follows that a constituent is Arg0 , i.e. CArg0 = 1 , if only one feature at a time is 1 , otherwise it is not an Arg0 , i.e. CArg0 = 0 . 
	</s>
	

	<s id="180">
		 In other words , CArg0 = Position XOR Voice , which is the classical example of a non-linear separable function that becomes separable in a superlinear space 
		<ref citStr="Cristianini and Shawe-Taylor , 2000" id="27" label="CEPF" position="28838">
			( Cristianini and Shawe-Taylor , 2000 )
		</ref>
		 . 
	</s>
	

	<s id="181">
		 After it was established that the best kernel for standard features is Kp3 , we carried out all the other experiments using it in the kernel combinations . 
	</s>
	

	<s id="182">
		 Table 2 and 3 show the single class ( f1 measure ) as well as multi-class classifier ( accuracy ) performance for PropBank and FrameNet respectively . 
	</s>
	

	<s id="183">
		 Each column of the two tables refers to a different kernel defined in the 8Preliminary experiments indicate that SVMs can reach 90 % by using the frame feature . 
	</s>
	

	<s id="184">
		 9Indeed , this is true in most part of the cases . 
	</s>
	

	<s id="185">
		 previous section . 
	</s>
	

	<s id="186">
		 The overall meaning is discussed in the following points : First , PAF alone has good performance , since in PropBank evaluation it outperforms the linear kernel ( Kp1 ) , 88.7 % vs. 86.7 % whereas in FrameNet , it shows a similar performance 79.5 % vs. 82.1 % ( compare tables with Figure 5 ) . 
	</s>
	

	<s id="187">
		 This suggests that PAF generates the same information as the standard features in a linear space . 
	</s>
	

	<s id="188">
		 However , when a degree greater than 1 is used for standard features , PAF is outperformed10 . 
	</s>
	

	<s id="189">
		 Args P3 PAF PAF+P PAF•P SCF+P SCF•P Arg0 90.8 88.3 90.6 90.5 94.6 94.7 Arg1 91.1 87.4 89.9 91.2 92.9 94.1 Arg2 80.0 68.5 77.5 74.7 77.4 82.0 Arg3 57.9 56.5 55.6 49.7 56.2 56.4 Arg4 70.5 68.7 71.2 62.7 69.6 71.1 ArgM 95.4 94.1 96.2 96.2 96.1 96.3 Acc . 
	</s>
	

	<s id="190">
		 90.5 88.7 90.2 90.4 92.4 93.2 Table 2 : Evaluation of Kernels on PropBank . 
	</s>
	

	<s id="191">
		 Roles P3 PAF PAF+P PAF•P SCF+P SCF•P agent 92.0 88.5 91.7 91.3 93.1 93.9 cause 59.7 16.1 41.6 27.7 42.6 57.3 degree 74.9 68.6 71.4 57.8 68.5 60.9 depict . 
	</s>
	

	<s id="192">
		 52.6 29.7 51.0 28.6 46.8 37.6 durat . 
	</s>
	

	<s id="193">
		 45.8 52.1 40.9 29.0 31.8 41.8 goal 85.9 78.6 85.3 82.8 84.0 85.3 instr . 
	</s>
	

	<s id="194">
		 67.9 46.8 62.8 55.8 59.6 64.1 mann. 81.0 81.9 81.2 78.6 77.8 77.8 Acc . 
	</s>
	

	<s id="195">
		 85.2 79.5 84.6 81.6 83.8 84.2 18 roles Table 3 : Evaluation of Kernels on FrameNet semantic roles . 
	</s>
	

	<s id="196">
		 Second , SCF improves the polynomial kernel ( d = 3 ) , i.e. the current state-of-the-art , of about 3 percent points on PropBank ( column SCF-P ) . 
	</s>
	

	<s id="197">
		 This suggests that ( a ) PAK can mea- sure the similarity between two SCF structures and ( b ) the sub-categorization information provides effective clues about the expected argument type . 
	</s>
	

	<s id="198">
		 The interesting consequence is that SCF together with PAK seems suitable to automatically cluster different verbs that have the same syntactic realization . 
	</s>
	

	<s id="199">
		 We note also that to fully exploit the SCF information it is necessary to use a kernel product ( K1 • K2 ) combination rather than the sum ( K1 + K2 ) , e.g. column SCF+P . 
	</s>
	

	<s id="200">
		 Finally , the FrameNet results are completely different . 
	</s>
	

	<s id="201">
		 No kernel combinations with both PAF and SCF produce an improvement . 
	</s>
	

	<s id="202">
		 On 10Unfortunately the use of a polynomial kernel on top the tree fragments to generate the XOR functions seems not successful . 
	</s>
	

	<s id="203">
		 0.91 0.9 0.89 0.88 0.87 0.86 0.85 0.84 0.83 0.82 FrameNet PropBank the contrary , the performance decreases , suggesting that the classifier is confused by this syntactic information . 
	</s>
	

	<s id="204">
		 The main reason for the different outcomes is that PropBank arguments are different from semantic roles as they are an intermediate level between syntax and semantic , i.e. they are nearer to grammatical functions . 
	</s>
	

	<s id="205">
		 In fact , in PropBank arguments are annotated consistently with syntactic alternations ( see the Annotation guidelines for Prop- Bank at www.cis.upenn.edu/—ace ) . 
	</s>
	

	<s id="206">
		 On the contrary FrameNet roles represent the final semantic product and they are assigned according to semantic considerations rather than syntactic aspects . 
	</s>
	

	<s id="207">
		 For example , Cause and Agent semantic roles have identical syntactic realizations . 
	</s>
	

	<s id="208">
		 This prevents SCF to distinguish between them . 
	</s>
	

	<s id="209">
		 Another minor reason may be the use of automatic parse-trees to extract PAF and SCF , even if preliminary experiments on automatic semantic shallow parsing of PropBank have shown no important differences versus semantic parsing which adopts Gold Standard parse-trees . 
	</s>
	

	<s id="210">
		 5 Conclusions In this paper , we have experimented with SVMs using the two novel convolution kernels PAF and SCF which are designed for the semantic structures derived from PropBank and FrameNet corpora . 
	</s>
	

	<s id="211">
		 Moreover , we have combined them with the polynomial kernel of standard features . 
	</s>
	

	<s id="212">
		 The results have shown that : First , SVMs using the above kernels are appealing for semantically parsing both corpora . 
	</s>
	

	<s id="213">
		 Second , PAF and SCF can be used to improve automatic classification of PropBank arguments as they provide clues about the predicate argument structure of the target verb . 
	</s>
	

	<s id="214">
		 For example , SCF improves ( a ) the classification state-of-the- art ( i.e. the polynomial kernel ) of about 3 percent points and ( b ) the best literature result of about 5 percent points . 
	</s>
	

	<s id="215">
		 Third , additional work is needed to design kernels suitable to learn the deep semantic contained in FrameNet as it seems not sensible to both PAF and SCF information . 
	</s>
	

	<s id="216">
		 Finally , an analysis of SVMs using polynomial kernels over standard features has explained why they largely outperform linear classifiers based-on standard features . 
	</s>
	

	<s id="217">
		 In the future we plan to design other structures and combine them with SCF , PAF and standard features . 
	</s>
	

	<s id="218">
		 In this vision the learning will be carried out on a set of structural features instead of a set of flat features . 
	</s>
	

	<s id="219">
		 Other studies may relate to the use of SCF to generate verb clusters . 
	</s>
	

	<s id="220">
		 Acknowledgments This research has been sponsored by the ARDA AQUAINT program . 
	</s>
	

	<s id="221">
		 In addition , I would like to thank Professor Sanda Harabagiu for her advice , Adrian Cosmin Bejan for implementing the feature extractor and Paul Mor^arescu for processing the FrameNet data . 
	</s>
	

	<s id="222">
		 Many thanks to the anonymous reviewers for their invaluable suggestions . 
	</s>
	

	<s id="223">
		 References Michael Collins and Nigel Duffy . 
	</s>
	

	<s id="224">
		 2002. New ranking algorithms for parsing and tagging : Kernels over discrete structures , and the voted perceptron . 
	</s>
	

	<s id="225">
		 In proceeding of ACL-02 . 
	</s>
	

	<s id="226">
		 Michael Collins . 
	</s>
	

	<s id="227">
		 1997. Three generative , lexicalized models for statistical parsing . 
	</s>
	

	<s id="228">
		 In proceedings of the ACL-97 , pages 16–23 , Somerset , New Jersey . 
	</s>
	

	<s id="229">
		 Nello Cristianini and John Shawe-Taylor . 
	</s>
	

	<s id="230">
		 2000. An introduction to Support Vector Machines . 
	</s>
	

	<s id="231">
		 Cam- bridge University Press . 
	</s>
	

	<s id="232">
		 Charles J. Fillmore . 
	</s>
	

	<s id="233">
		 1982. Frame semantics . 
	</s>
	

	<s id="234">
		 In Lin- guistics in the Morning Calm , pages 111–137 . 
	</s>
	

	<s id="235">
		 Daniel Gildea and Daniel Jurasfky . 
	</s>
	

	<s id="236">
		 2002. Auto- matic labeling of semantic roles . 
	</s>
	

	<s id="237">
		 Computational Linguistic . 
	</s>
	

	<s id="238">
		 Daniel Gildea and Martha Palmer . 
	</s>
	

	<s id="239">
		 2002. The necessity of parsing for predicate argument recognition . 
	</s>
	

	<s id="240">
		 In proceedings of ACL-02 , Philadelphia , PA . 
	</s>
	

	<s id="241">
		 R. Jackendoff . 
	</s>
	

	<s id="242">
		 1990. Semantic Structures , Current Studies in Linguistics series . 
	</s>
	

	<s id="243">
		 Cambridge , Massachusetts : The MIT Press . 
	</s>
	

	<s id="244">
		 T. Joachims . 
	</s>
	

	<s id="245">
		 1999. Making large-scale SVM learning practical . 
	</s>
	

	<s id="246">
		 In Advances in Kernel Methods - Support Vector Learning . 
	</s>
	

	<s id="247">
		 Paul Kingsbury and Martha Palmer . 
	</s>
	

	<s id="248">
		 2002. From treebank to propbank . 
	</s>
	

	<s id="249">
		 In proceedings of LREC02 , Las Palmas , Spain . 
	</s>
	

	<s id="250">
		 M. P. Marcus , B. Santorini , and M. A. Marcinkiewicz . 
	</s>
	

	<s id="251">
		 1993. Building a large annotated corpus of english : The penn treebank . 
	</s>
	

	<s id="252">
		 Computational Linguistics . 
	</s>
	

	<s id="253">
		 Alessandro Moschitti and Cosmin Adrian Bejan . 
	</s>
	

	<s id="254">
		 2004. A semantic kernel for predicate argument classification . 
	</s>
	

	<s id="255">
		 In proceedings of CoNLL-04 , Boston , USA . 
	</s>
	

	<s id="256">
		 Kadri Hacioglu , Sameer Pradhan , Wayne Ward , James H. Martin , and Daniel Jurafsky . 
	</s>
	

	<s id="257">
		 2003. Shallow Semantic Parsing Using Support Vector Machines . 
	</s>
	

	<s id="258">
		 TR-CSLR-2003-03 , University of Colorado . 
	</s>
	

	<s id="259">
		 Mihai Surdeanu , Sanda M. Harabagiu , John Williams , and John Aarseth . 
	</s>
	

	<s id="260">
		 2003. Using predicate-argument structures for information extraction . 
	</s>
	

	<s id="261">
		 In proceedings of ACL-03 , Sapporo , Japan . 
	</s>
	

	<s id="262">
		 V. Vapnik . 
	</s>
	

	<s id="263">
		 1995. The Nature of Statistical Learning Theory . 
	</s>
	

	<s id="264">
		 Springer-Verlag New York , Inc. 
	</s>
	


</acldoc>
