<?xml version="1.0" encoding="iso-8859-1"?>
<acldoc acl_id="P04-1042">
	

	<s id="1">
		 Deep dependencies from context-free statistical parsers : correcting the surface dependency approximation Roger Levy Christopher D. Manning Department of Linguistics Departments of Computer Science and Linguistics Stanford University Stanford University rog@stanford.edu manning@cs.stanford.edu Abstract We present a linguistically-motivated algorithm for reconstructing nonlocal dependency in broad-coverage context-free parse trees derived from treebanks . 
	</s>
	

	<s id="2">
		 We use an algorithm based on loglinear classifiers to augment and reshape context-free trees so as to reintroduce underlying nonlocal dependencies lost in the context-free approximation . 
	</s>
	

	<s id="3">
		 We find that our algorithm compares favorably with prior work on English using an existing evaluation metric , and also introduce and argue for a new dependency-based evaluation metric . 
	</s>
	

	<s id="4">
		 By this new evaluation metric our algorithm achieves 60 % error reduction on gold-standard input trees and 5 % error reduction on state-of- the-art machine-parsed input trees , when compared with the best previous work . 
	</s>
	

	<s id="5">
		 We also present the first results on non- local dependency reconstruction for a language other than English , comparing performance on English and German . 
	</s>
	

	<s id="6">
		 Our new evaluation metric quantitatively corroborates the intuition that in a language with freer word order , the surface dependencies in context-free parse trees are a poorer approximation to underlying dependency structure . 
	</s>
	

	<s id="7">
		 1 Introduction While parsers are been used for other purposes , the primary motivation for syntactic parsing is as an aid to semantic interpretation , in pursuit of broader goals of natural language understanding . 
	</s>
	

	<s id="8">
		 Proponents of traditional ‘deep’ or ‘precise’ approaches to syntax , such as GB , CCG , HPSG , LFG , or TAG , have argued that sophisticated grammatical formalisms are essential to resolving various hidden relationships such as the source phrase of moved whphrases in questions and relativizations , or the controller of clauses without an overt subject . 
	</s>
	

	<s id="9">
		 Knowledge of these hidden relationships is in turn essential to semantic interpretation of the kind practiced in the semantic parsing 
		<ref citStr="Gildea and Jurafsky , 2002" id="1" label="CEPF" position="2255">
			( Gildea and Jurafsky , 2002 )
		</ref>
		 and QA 
		<ref citStr="Pasca and Harabagiu , 2001" id="2" label="CEPF" position="2293">
			( Pasca and Harabagiu , 2001 )
		</ref>
		 literatures . 
	</s>
	

	<s id="10">
		 However , work in statistical parsing has for the most part put these needs aside , being content to recover surface context-free ( CF ) phrase structure trees . 
	</s>
	

	<s id="11">
		 This perhaps reflects the fact that context-free phrase structure grammar ( CFG ) is in some sense at the the heart of the majority of both formal and computational syntactic research . 
	</s>
	

	<s id="12">
		 Although , upon introducing it , 
		<ref citStr="Chomsky ( 1956 )" id="3" label="CJPF" position="2732">
			Chomsky ( 1956 )
		</ref>
		 rejected CFG as an adequate framework for natural language description , the majority of work in the last half century has used context-free structural descriptions and related methodologies in one form or another as an important component of syntactic analysis . 
	</s>
	

	<s id="13">
		 CFGs seem adequate to weakly generate almost all common natural language structures , and also facilitate a transparent predicate-argument and/or semantic interpretation for the more basic ones 
		<ref citStr="Gazdar et al. , 1985" id="4" label="CEPF" position="3224">
			( Gazdar et al. , 1985 )
		</ref>
		 . 
	</s>
	

	<s id="14">
		 Nevertheless , despite their success in providing surface phrase structure analyses , if statistical parsers and the representations they produce do not provide a useful stepping stone to recovering the hidden relationships , they will ultimately come to be seen as a dead end , and work will necessarily return to using richer formalisms . 
	</s>
	

	<s id="15">
		 In this paper we attempt to establish to what degree current statistical parsers are a useful step in analysis by examining the performance of further statistical classifiers on non-local dependency recovery from CF parse trees . 
	</s>
	

	<s id="16">
		 The natural isomorphism from CF trees to dependency trees induces only local dependencies , derived from the head- sister relation in a CF local tree . 
	</s>
	

	<s id="17">
		 However , if the output of a context-free parser can be algorithmically augmented to accurately identify and incorporate nonlocal dependencies , then we can say that the context-free parsing model is a safe approximation to the true task of dependency reconstruction . 
	</s>
	

	<s id="18">
		 We investigate the safeness of this approximation , devising an algorithm to reconstruct non-local dependencies from context-free parse trees using log- linear classifiers , tested on treebanks of not only English but also German , a language with much freer word order and correspondingly more discontinuity than English . 
	</s>
	

	<s id="19">
		 This algorithm can be used as an intermediate step between the surface output trees of modern statistical parsers and semantic interpretation systems for a variety of tasks.1 1Many linguistic and technical intricacies are involved in the interpretation and use of non-local annotation structure found in treebanks . 
	</s>
	

	<s id="20">
		 A more complete exposition of the work presented here can be found in 
		<ref citStr="Levy ( 2004 )" id="5" label="CEPF" position="5005">
			Levy ( 2004 )
		</ref>
		 . 
	</s>
	

	<s id="21">
		 Figure 1 : Example of empty and nonlocal annotations from the Penn Treebank of English , including null complementizers ( 0 ) , relativization ( *T*-1 ) , rightextraposition ( *ICH*-2 ) , and syntactic control ( *-3 ) . 
	</s>
	

	<s id="22">
		 1.1 Previous Work Previous work on nonlocal dependency has focused entirely on English , despite the disparity in type and frequency of various non-local dependency constructions for varying languages 
		<ref citStr="Kruijff , 2002" id="6" label="CEPF" position="5465">
			( Kruijff , 2002 )
		</ref>
		 . 
	</s>
	

	<s id="23">
		 Collins (1999)’s Model 3 investigated GPSG-style trace threading for resolving nonlocal relative pronoun dependencies . 
	</s>
	

	<s id="24">
		 
		<ref citStr="Johnson ( 2002 )" id="7" label="CEPF" position="5623">
			Johnson ( 2002 )
		</ref>
		 was the first post-processing approach to non-local dependency recovery , using a simple pattern-matching algorithm on context-free trees . 
	</s>
	

	<s id="25">
		 Dienes and Dubey ( 2003a,b ) and 
		<ref citStr="Dienes ( 2003 )" id="8" label="CEPF" position="5821">
			Dienes ( 2003 )
		</ref>
		 approached the problem by pre- identifying empty categories using an HMM on unparsed strings and threaded the identified empties into the category structure of a context-free parser , finding that this method compared favorably with both Collins’ and Johnson’s . 
	</s>
	

	<s id="26">
		 Traditional LFG parsing , in both non-stochastic 
		<ref citStr="Kaplan and Maxwell , 1993" id="9" label="CEPF" position="6174">
			( Kaplan and Maxwell , 1993 )
		</ref>
		 and stochastic 
		<ref citStr="Riezler et al. , 2002" id="10" label="CEPF" position="6190">
			( Riezler et al. , 2002 
		</ref>
		<ref citStr="Kaplan et al. , 2004" id="11" label="CEPF" position="6214">
			; Kaplan et al. , 2004 )
		</ref>
		 incarnations , also divides the labor of local and nonlocal dependency identification into two phases , starting with context-free parses and continuing by augmentation with functional information . 
	</s>
	

	<s id="27">
		 2 Datasets The datasets used for this study consist of the Wall Street Journal section of the Penn Treebank of English ( WSJ ) and the context-free version of the NEGRA ( version 2 ) corpus of German 
		<ref citStr="Skut et al. , 1997b" id="12" label="OERF" position="6670">
			( Skut et al. , 1997b )
		</ref>
		 . 
	</s>
	

	<s id="28">
		 Full-size experiments on WSJ described in Section 4 used the standard sections 2-21 for training , 24 for development , and trees whose yield is under 100 words from section 23 for testing . 
	</s>
	

	<s id="29">
		 Experiments described in Section 4.3 used the same development and test sets but files 200-959 of WSJ as a smaller training set ; for NEGRA we followed 
		<ref citStr="Dubey and Keller ( 2003 )" id="13" label="CERF" position="7059">
			Dubey and Keller ( 2003 )
		</ref>
		 in using the first 18,602 sentences for training , the last 1,000 for develop- ment , and the previous 1,000 for testing . 
	</s>
	

	<s id="30">
		 Consistent with prior work and with common practice in statistical parsing , we stripped categories of all functional tags prior to training and testing ( though in several cases this seems to have been a limiting move ; see Section 5 ) . 
	</s>
	

	<s id="31">
		 Nonlocal dependency annotation in Penn Tree- banks can be divided into three major types : unindexed empty elements , dislocations , and control . 
	</s>
	

	<s id="32">
		 The first type consists primarily of null complementizers , as exemplified in Figure 1 by the null relative pronoun 0 ( c.f. aspects that it sees ) , and do not participate in ( though they may mediate ) nonlocal dependency . 
	</s>
	

	<s id="33">
		 The second type consists of a dislocated element coindexed with an origin site of semantic interpretation , as in the association in Figure 1 of WHNP-1 with the direct object position of sees ( a relativization ) , and the association of S2 with the ADJP quick ( a right dislocation ) . 
	</s>
	

	<s id="34">
		 This type encompasses the classic cases of nonlocal dependency : topicalization , relativization , wh- movement , and right dislocation , as well as expletives and other instances of non-canonical argument positioning . 
	</s>
	

	<s id="35">
		 The third type involves control loci in syntactic argument positions , sometimes coindexed with overt controllers , as in the association of the NP Farmers with the empty subject position of the S2 node . 
	</s>
	

	<s id="36">
		 ( An example of a control locus with no controller would be [ S NP-* [ VP Eating ice cream ] ] is fun . 
	</s>
	

	<s id="37">
		 ) Controllers are to be interpreted as syntactic ( and possibly semantic ) arguments both in their overt position and in the position of loci they control . 
	</s>
	

	<s id="38">
		 This type encompasses raising , control , passivization , and unexpressed subjects of to- infinitive and gerund verbs , among other constructions.2 NEGRA’s original annotation is as dependency trees with phrasal nodes , crossing branches , and no empty elements . 
	</s>
	

	<s id="39">
		 However , the distribution includes a context-free version produced algorithmically by recursively remapping discontinuous parts of nodes upward into higher phrases and marking their sites of origin .3 The resulting “traces” correspond roughly to a subclass of the second class of Penn Treebank empties discussed above , and include wh- movement , topicalization , right extrapositions from NP , expletives , and scrambling of sub- 2 Four of the annotation errors in WSJ lead to uninterpretable dislocation and sharing patterns , including failure to annotate dislocations corresponding to marked origin sites , and mislabelings of control loci as origin sites of dislocation that lead to cyclic dislocations ( which are explicitly prohibited in WSJ annotation guidelines ) . 
	</s>
	

	<s id="40">
		 We corrected these errors manually before model testing and training . 
	</s>
	

	<s id="41">
		 3For a detailed description of the algorithm for creating the context-free version of NEGRA , see 
		<ref citStr="Skut et al . ( 1997a )" id="14" label="CEPF" position="10110">
			Skut et al . ( 1997a )
		</ref>
		 . 
	</s>
	

	<s id="42">
		 to NP-3 NNP Farmers JJ quick S *ICH*-2 NP NN yesterday S-2 NP *-3 VP VP VBD was ADJP VP TO S VP VBZ *T*-1 point VB PRT RP out DT the NP NN problems NP SBAR WHNP-1 0 NP PRP it NP sees S. . 
	</s>
	

	<s id="43">
		 “The RMV will not begin to be formed for a long time.” Figure 2 : Nonlocal dependencies via right-extraposition ( *T1* ) and topicalization ( *T2* ) in the NEGRA corpus of German , before ( top ) and after ( bottom ) transformation to context-free form . 
	</s>
	

	<s id="44">
		 Dashed lines show where nodes go as a result of remapping into context-free form . 
	</s>
	

	<s id="45">
		 jects after other complements . 
	</s>
	

	<s id="46">
		 The positioning of NEGRA’s “traces” inside the mother node is completely algorithmic ; a dislocated constituent C has its trace at the edge of the original mother closest to C’s overt position . 
	</s>
	

	<s id="47">
		 Given a context-free NEGRA tree shorn of its trace/antecedent notation , however , it is far from trivial to determine which nodes are dislocated , and where they come from . 
	</s>
	

	<s id="48">
		 Figure 2 shows an annotated sentence from the NEGRA corpus with discontinuities due to right extraposition ( *T1* ) and topicalization ( *T2* ) , before and after transformation into context-free form with traces . 
	</s>
	

	<s id="49">
		 3 Algorithm Corresponding to the three types of empty-element annotation found in the Penn Treebank , our algorithm divides the process of CF tree enhancement into three phases . 
	</s>
	

	<s id="50">
		 Each phase involves the identification of a certain subset of tree nodes to be operated on , followed by the application of the appropriate operation to the node . 
	</s>
	

	<s id="51">
		 Operations may involve the insertion of a category at some position among a node’s daughters ; the marking of certain nodes as dislocated ; or the relocation of dislocated nodes to other positions within the tree . 
	</s>
	

	<s id="52">
		 The content and ordering of phases is consistent with the syntactic theory upon which treebank annotation is based . 
	</s>
	

	<s id="53">
		 For example , WSJ annotates relative clauses lacking overt relative pronouns , such as the SBAR in Figure 1 , with a trace in the relativization site whose antecedent is an empty relative pronoun . 
	</s>
	

	<s id="54">
		 This requires that empty relative pronoun insertion precede dislocated element identification . 
	</s>
	

	<s id="55">
		 Likewise , dislocated elements can serve as controllers of control loci , based on their originating site , so it is sensible to return dislocated nodes to their originating sites before identifying control loci and their controllers . 
	</s>
	

	<s id="56">
		 For WSJ , the three phases are : 1. ( a ) Determine nodes at which to insert null COMPlementizers4 ( IDENTNULL ) ( b ) For each COMP insertion node , determine position of each insertion and insert COMP ( INSERTNULL ) 2 . 
	</s>
	

	<s id="57">
		 ( a ) Classify each tree node as +/- DISLOCATED ( IDENTMOVED ) ( b ) For each DISLOCATED node , choose an ORIGIN node ( RELOCMOVED ) ( c ) For each pair ( DISLOCATED,origin ) , choose a position of insertion and insert dislocated ( INSERTRELOC ) 3 . 
	</s>
	

	<s id="58">
		 ( a ) Classify each node as +/- control LOCUS ( IDENTLOCUS ) ( b ) For each LOCUS , determine position of insertion and insert LOCUS ( INSERTLOCUS ) ( c ) For each LOCUS , determine CONTROLLER ( if any ) ( FINDCONTROLLER ) Note in particular that phase 2 involves the classification of overt tree nodes as dislocated , followed by the identification of an origin site ( annotated in the treebank as an empty node ) for each dislocated element ; whereas phase 3 involves the identification of ( empty ) control loci first , and of controllers later . 
	</s>
	

	<s id="59">
		 This approach contrasts with 
		<ref citStr="Johnson ( 2002 )" id="15" label="CJPF" position="13697">
			Johnson ( 2002 )
		</ref>
		 , who treats empty/antecedent identification as a joint task , and with Dienes and Dubey ( 2003a,b ) , who always identify empties first and determine antecedents later . 
	</s>
	

	<s id="60">
		 Our motivation is that it should generally be easier to determine whether an overt element is dislocated than whether a given position is the origin of some yet unknown dislocated element ( particularly in the absence of a sophisticated model of argument expression ) ; but control loci are highly predictable from local context , such as the subjectless non-finite S in Figure 1’s S-2.5 Indeed this difference seems to be implicit in the non- local feature templates used by Dienes and Dubey ( 2003a,b ) in their empty element tagger , in particular lookback for wh- words preceding a candidate verb . 
	</s>
	

	<s id="61">
		 As described in Section 2 , NEGRA’s nonlocal annotation schema is much simpler , involving no 4The WSJ contains a number of SBARs headed by empty complementizers with trace S’s . 
	</s>
	

	<s id="62">
		 These SBARs are introduced in our algorithm as projections of identified empty complementizers as daughters of non-SBAR categories . 
	</s>
	

	<s id="63">
		 5Additionally , whereas dislocated nodes are always overt , control loci may be controlled by other ( null ) control loci , meaning that identifying controllers before control loci would still entail looking for nulls . 
	</s>
	

	<s id="64">
		 S VAFIN VP $ , $ . 
	</s>
	

	<s id="65">
		 AP wird PP VVPP . 
	</s>
	

	<s id="66">
		 ADV NP ADJD PROAV begonnen , VP Erst ADJA NN sp¨ater damit NP VZ lange Zeit ART NE PTKZU VVINF den RMV zu schaffen lange long Zeit time damit with it den the RMV RMV zu to schaffen form ADV AP-2 NP VAFIN wird will S VVPP ADJD VP $ , , NP VP-1 VZ $ . 
	</s>
	

	<s id="67">
		 . 
	</s>
	

	<s id="68">
		 *T2* PP NE ART NN PTKZU PROAV VVINF ADJA *T1 * begonnen be begun Erst not until sp¨ater later IDENTMOVED S Expletive dislocation NP(it/there) VP S/SBAR Figure 3 : Different classifiers’ specialized tree-matching fragments and their purposes uncoindexed empties or control loci . 
	</s>
	

	<s id="69">
		 Correspondingly , our NEGRA algorithm includes only phase 2 of the WSJ algorithm , step ( c ) of which is trivial for NEGRA due to the deterministic positioning of trace insertion in the treebank . 
	</s>
	

	<s id="70">
		 In each case we use a loglinear model for node classification , with a combination of quadratic regularization and thresholding by individual feature count to prevent overfitting . 
	</s>
	

	<s id="71">
		 In the second and third parts of phases 2 and 3 , when determining an originating site or controller for a given node N , or an insertion position for a node N ' in N , we use a competition-based setting , using a binary classification ( yes/no for association with N ) on each node in the tree , and during testing choosing the node with the highest score for positive association with N.6 All other phases of classification involve independent decisions at each node . 
	</s>
	

	<s id="72">
		 In phase 3 , we include a special zero node to indicate a control locus with no antecedent . 
	</s>
	

	<s id="73">
		 3.1 Feature templates Each subphase of our dependency reconstruction algorithm involves the training of a separate model and the development of a separate feature set . 
	</s>
	

	<s id="74">
		 We found that it was important to include both a variety of general feature templates and a number of manually designed , specialized features to resolve specific problems observed for individual classifiers . 
	</s>
	

	<s id="75">
		 We developed all feature templates exclusively on the training and development sets specified in Section 2 . 
	</s>
	

	<s id="76">
		 Table 1 shows which general feature templates we used in each classifier . 
	</s>
	

	<s id="77">
		 The features are 6The choice of a unique origin site makes our algorithm unable to deal with right-node raising or parasitic gaps . 
	</s>
	

	<s id="78">
		 Cases of right-node raising could be automatically transformed into single-origin dislocations by making use of a theory of coordination such as 
		<ref citStr="Maxwell and Manning ( 1996 )" id="16" label="CEPF" position="17560">
			Maxwell and Manning ( 1996 )
		</ref>
		 , while parasitic gaps could be handled with the introduction of a secondary classifier . 
	</s>
	

	<s id="79">
		 Both phenomena are low-frequency , however , and we ignore them here . 
	</s>
	

	<s id="80">
		 Feature type TAG ® / / HD / CAT x MCAT / CATxMCATxGCAT / / / CATxHDxMCATxMHD ® CATxTAGxMCATxMTAG ® CAT x TAG / / CAT x HD ® (FIRST/LAST)CAT / / (L/RSIS)CAT / / DPOS x CAT / PATH / / CAT x RCAT / TAG x RCAT / CAT x TAG x RCAT / CAT x RCAT x DPO S / HDxRHD ® CAT xHDxRHD / CATxDCAT / / / / MHDxHD ® # Special 9 0 11 0 0 12 0 3 Table 1 : Shared feature templates . 
	</s>
	

	<s id="81">
		 See text for template descriptions . 
	</s>
	

	<s id="82">
		 # Special is the number of special templates used for the classifier . 
	</s>
	

	<s id="83">
		 ® denotes that all subsets of the template conjunction were included . 
	</s>
	

	<s id="84">
		 coded as follows . 
	</s>
	

	<s id="85">
		 The prefixes { 0,M,G,D,R } indicate that the feature value is calculated with respect to the node in question , its mother , grandmother , daughter , or relative node respectively.7 { CAT,POS,TAG,WORD } stand for syntactic category , position ( of daughter ) in mother , head tag , and head word respectively . 
	</s>
	

	<s id="86">
		 For example , when determining whether an infinitival VP is extraposed , such as S-2 in Figure 1 , the plausibility of the VP head being a deep dependent of the head verb is captured with the MHD x HD template . 
	</s>
	

	<s id="87">
		 (FIRST/LAST)CAT and (L/RSIS)CAT are templates used for choosing the position to insert insert relocated nodes , respectively recording whether a node of a given category is the first/last daughter , and the syntactic category of a node’s left/right sisters . 
	</s>
	

	<s id="88">
		 PATH is the syntactic path between relative and base node , defined as the list of the syntactic categories on the ( inclusive ) node path linking the relative node to the node in question , paired with whether the step on the path was upward or downward . 
	</s>
	

	<s id="89">
		 For example , in Figure 2 the syntactic path from VP-1 to PP is [ T-VP,TS , ~-VP , ~-PP ] . 
	</s>
	

	<s id="90">
		 This is a crucial feature for the relativized classifiers RELOCATEMOVED and FIND- CONTROLLER ; in an abstract sense it mediates the gap-threading information incorporated into GPSG- 7The relative node is DISLOCATED in RELOCMOVED and LOCUS in FINDCONTROLLER . 
	</s>
	

	<s id="91">
		 IDENTLOCUS S VP h VP-internal context to determine null subjecthood INSERTNULLS S VP Possible null com- plementizer ( records syntactic path from every S in sentence ) PCF P AoP JoP D G AoG JoG 91.2 87.6 90.5 90.0 88.3 95.7 99.4 98.5 91.6 89.9 91.4 91.2 89.4 97.9 99.8 99.6 93.3 83.4 91.2 89.9 89.2 89.0 98.0 96.0 91.2 87.3 90.2 89.6 88.0 95.2 99.0 97.7 73.1 72.8 72.9 72.8 72.5 99.7 99.6 98.8 94.4 66.7 89.3 84.9 85.0 72.6 99.4 94.1 70.1 69.7 69.5 69.7 67.7 99.4 99.4 99.7 Gold trees Parser output Jn Pres Jn DD Pres 62.4 75.3 55.6 ( 69.5 ) 61.1 85.1 67.6 80.0 ( 82.0 ) 63.3 89.3 99.6 77.1 ( 48.8 ) 87.0 74.8 74.7 71.0 73.8 71.0 90 93.3 87 84.5 83.6 NP-* WH-t 0 SBAR S-t Overall NP S VP ADJP SBAR ADVP Table 2 : Comparison with previous work using Johnson’s PARSEVAL metric . 
	</s>
	

	<s id="92">
		 Jn is 
		<ref citStr="Johnson ( 2002 )" id="17" label="CJPF" position="20606">
			Johnson ( 2002 )
		</ref>
		 ; DD is 
		<ref citStr="Dienes and Dubey ( 2003b )" id="18" label="CJPF" position="20641">
			Dienes and Dubey ( 2003b )
		</ref>
		 ; Pres is the present work . 
	</s>
	

	<s id="93">
		 style 
		<ref citStr="Gazdar et al. , 1985" id="19" label="OEPF" position="20710">
			( Gazdar et al. , 1985 )
		</ref>
		 parsers , and in concrete terms it closely matches the information derived from Johnson (2002)’s connected local tree set patterns . 
	</s>
	

	<s id="94">
		 
		<ref citStr="Gildea and Jurafsky ( 2002 )" id="20" label="CEPF" position="20882">
			Gildea and Jurafsky ( 2002 )
		</ref>
		 is to our knowledge the first use of such a feature for classification tasks on syntactic trees ; they found it important for the related task of semantic role identification . 
	</s>
	

	<s id="95">
		 We expressed specialized hand-coded feature templates as tree-matching patterns that capture a fragment of the content of the pattern in the feature value . 
	</s>
	

	<s id="96">
		 Representative examples appear in Figure 3 . 
	</s>
	

	<s id="97">
		 The italicized node is the node for which a given feature is recorded ; underscores indicate variables that can match any category ; and the angle-bracketed parts of the tree fragment , together with an index for the pattern , determine the feature value.8 4 Evaluation 4.1 Comparison with previous work Our algorithm’s performance can be compared with the work of 
		<ref citStr="Johnson ( 2002 )" id="21" label="CJPF" position="21671">
			Johnson ( 2002 )
		</ref>
		 and 
		<ref citStr="Dienes and Dubey ( 2003a )" id="22" label="CJPF" position="21702">
			Dienes and Dubey ( 2003a )
		</ref>
		 on WSJ . 
	</s>
	

	<s id="98">
		 Valid comparisons exist for the insertion of uncoindexed empty nodes ( COMP and ARB-SUBJ ) , identification of control and raising loci ( CONTROLLOCUS ) , and pairings of dislocated and controller/raised nodes with their origins ( DISLOC,CONTROLLER ) . 
	</s>
	

	<s id="99">
		 In Table 2 we present comparative results , using the PARSEVAL-based evaluation metric introduced by 
		<ref citStr="Johnson ( 2002 )" id="23" label="OERF" position="22100">
			Johnson ( 2002 )
		</ref>
		 – a correct empty category inference requires the string position of the empty category , combined with the left and right boundaries plus syntactic category of the antecedent , if any , for purposes of comparison.9,10 Note that this evaluation metric does not require correct attachment of the empty category into 8A complete description of feature templates can be found at http://nlp.stanford.edu/˜rog/acl2004/templates/index.html 9For purposes of comparability with 
		<ref citStr="Johnson ( 2002 )" id="24" label="CEPF" position="22589">
			Johnson ( 2002 )
		</ref>
		 we used Charniak’s 2000 parser as P. 10Our algorithm was evaluated on a more stringent standard for NP-* than in previous work : control loci-related mappings were done after dislocated nodes were actually relocated by the algorithm , so an incorrect dislocation remapping can render incorrect the indices of a correct NP-* labeled bracketing . 
	</s>
	

	<s id="100">
		 Additionally , our algorithm does not distinguish the syntactic cate- Table 3 : Typed dependency F1 performance when composed with statistical parser . 
	</s>
	

	<s id="101">
		 PCF is parser output evaluated by context-free ( shallow ) dependencies ; all others are evaluated on deep dependencies . 
	</s>
	

	<s id="102">
		 P is parser , G is string-to-context-free-gold-tree mapping , A is present remapping algorithm , J is Johnson 2002 , D is the COMBINED model of Dienes 2003 . 
	</s>
	

	<s id="103">
		 the parse tree . 
	</s>
	

	<s id="104">
		 In Figure 1 , for example , WHNP1 could be erroneously remapped to the right edge of any S or VP node in the sentence without resulting in error according to this metric . 
	</s>
	

	<s id="105">
		 We therefore abandon this metric in further evaluations as it is not clear whether it adequately approximates performance in predicate-argument structure recovery . 
	</s>
	

	<s id="106">
		 11 4.2 Composition with a context-free parser If we think of a statistical parser as a function from strings to CF trees , and the nonlocal dependency recovery algorithm A presented in this paper as a function from trees to trees , we can naturally compose our algorithm with a parser P to form a function A o P from strings to trees whose dependency interpretation is , hopefully , an improvement over the trees from P . 
	</s>
	

	<s id="107">
		 To test this idea quantitatively we evaluate performance with respect to recovery of typed dependency relations between words . 
	</s>
	

	<s id="108">
		 A dependency relation , commonly employed for evaluation in the statistical parsing literature , is defined at a node N of a lexicalized parse tree as a pair ( wi , wj ) where wi is the lexical head of N and wj is the lexical head of some non-head daughter of N. Dependency relations may further be typed according to information at or near the relevant tree node ; 
		<ref citStr="Collins ( 1999 )" id="25" label="CEPF" position="24735">
			Collins ( 1999 )
		</ref>
		 , for example , reports dependency scores typed on the syntactic categories of the mother , head daughter , and dependent daughter , plus on whether the dependent precedes or follows the head . 
	</s>
	

	<s id="109">
		 We present here dependency evaluations where the gold-standard dependency set is defined by the remapped tree , typed gory of null insertions , whereas previous work has ; as a result , the null complementizer class 0 and W H-t dislocation class are aggregates of classes used in previous work . 
	</s>
	

	<s id="110">
		 11
		<ref citStr="Collins ( 1999 )" id="26" label="CEPF" position="25262">
			Collins ( 1999 )
		</ref>
		 reports 93.8%/90.1 % precision/recall in his Model 3 for accurate identification of relativization site in non- infinitival relative clauses . 
	</s>
	

	<s id="111">
		 This figure is difficult to compare directly with other figures in this section ; a tree search indicates that non-infinitival subjects make up at most 85.4 % of the WHNP dislocations in WSJ . 
	</s>
	

	<s id="112">
		 WSJ(full) WSJ(sm) NEGRA Performance on gold trees Performance on parsed trees ID Rel Combo ID Combo P R F1 Acc P R F1 P R F1 P R F1 92.0 82.9 87.2 95.0 89.6 80.1 84.6 34.5 47.6 40.0 17.8 24.3 20.5 92.3 79.5 85.5 93.3 90.4 77.2 83.2 38.0 47.3 42.1 19.7 24.3 21.7 73.9 64.6 69.0 85.1 63.3 55.4 59.1 48.3 39.7 43.6 20.9 17.2 18.9 Table 4 : Cross-linguistic comparison of dislocated node identification and remapping . 
	</s>
	

	<s id="113">
		 ID is correct identification of nodes as +/– dislocated ; Rel is relocation of node to correct mother given gold-standard data on which nodes are dislocated ( only applicable for gold trees ) ; Combo is both correct identification and remapping . 
	</s>
	

	<s id="114">
		 by syntactic category of the mother node . 
	</s>
	

	<s id="115">
		 12 In Figure 1 , for example , to would be an ADJP dependent of quick rather than a VP dependent of was ; and Farmers would be an S dependent both of to in to point out ... and of was . 
	</s>
	

	<s id="116">
		 We use the head-finding rules of 
		<ref citStr="Collins ( 1999 )" id="27" label="CERF" position="26594">
			Collins ( 1999 )
		</ref>
		 to lexicalize trees , and assume that null complementizers do not participate in dependency relations . 
	</s>
	

	<s id="117">
		 To further compare the results of our algorithm with previous work , we obtained the output trees produced by 
		<ref citStr="Johnson ( 2002 )" id="28" label="CJPF" position="26834">
			Johnson ( 2002 )
		</ref>
		 and 
		<ref citStr="Dienes ( 2003 )" id="29" label="CJPF" position="26854">
			Dienes ( 2003 )
		</ref>
		 and evaluated them on typed dependency performance . 
	</s>
	

	<s id="118">
		 Table 3 shows the results of this evaluation . 
	</s>
	

	<s id="119">
		 For comparison , we include shallow dependency accuracy for Charniak’s parser under PCF . 
	</s>
	

	<s id="120">
		 4.3 Cross-linguistic comparison In order to compare the results of nonlocal dependency reconstruction between languages , we must identify equivalence classes of nonlocal dependency annotation between treebanks . 
	</s>
	

	<s id="121">
		 NEGRA’s nonlocal dependency annotation is quite different from WSJ , as described in Section 2 , ignoring controlled and arbitrary unexpressed subjects . 
	</s>
	

	<s id="122">
		 The natural basis of comparison is therefore the set of all nonlocal NEGRA annotations against all WSJ dislocations , excluding relativizations ( defined simply as dislocated wh- constituents under SBAR).13 Table 4 shows the performance comparison between WSJ and NEGRA of IDENTDISLOC and RELOCMOVED , on sentences of 40 tokens or less . 
	</s>
	

	<s id="123">
		 For this evaluation metric we use syntactic category and left &amp; right edges of ( 1 ) dislocated nodes ( ID ) ; and ( 2 ) originating mother node to which dislocated node is mapped ( Rel ) . 
	</s>
	

	<s id="124">
		 Combo requires both ( 1 ) and ( 2 ) to be correct . 
	</s>
	

	<s id="125">
		 NEGRA is smaller than WSJ ( ^350,000 words vs. 1 million ) , so for fair 12 Unfortunately , 46 WSJ dislocation annotations in this test- set involve dislocated nodes dominating their origin sites . 
	</s>
	

	<s id="126">
		 It is not entirely clear how to interpret the intended semantics of these examples , so we ignore them in evaluation . 
	</s>
	

	<s id="127">
		 13 The interpretation of comparative results must be modulated by the fact that more total time was spent on feature engineering for WSJ than for NEGRA , and the first author , who engineered the NEGRA feature set , is not a native speaker of German . 
	</s>
	

	<s id="128">
		 comparison we tested WSJ using the smaller training set described in Section 2 , comparable in size to NEGRA’s . 
	</s>
	

	<s id="129">
		 Since the positioning of traces within NEGRA nodes is trivial , we evaluate remapping and combination performances requiring only proper selection of the originating mother node ; thus we carry the algorithm out on both treebanks through step ( 2b ) . 
	</s>
	

	<s id="130">
		 This is adequate for purposes of our typed dependency evaluation in Section 4.2 , since typed dependencies do not depend on positional information . 
	</s>
	

	<s id="131">
		 State-of-the-art statistical parsing is far better on WSJ 
		<ref citStr="Charniak , 2000" id="30" label="OERF" position="29285">
			( Charniak , 2000 )
		</ref>
		 than on NEGRA 
		<ref citStr="Dubey and Keller , 2003" id="31" label="OERF" position="29327">
			( Dubey and Keller , 2003 )
		</ref>
		 , so for comparison of parser-composed dependency performance we used vanilla PCFG models for both WSJ and NEGRA trained on comparably-sized datasets ; in addition to making similar types of independence assumptions , these models performed relatively comparably on labeled bracketing measures for our development sets ( 73.2 % performance for WSJ versus 70.9 % for NEGRA ) . 
	</s>
	

	<s id="132">
		 Table 5 compares the testset performance of algorithms on the two treebanks on the typed dependency measure introduced in Section 4.2 . 
	</s>
	

	<s id="133">
		 14 5 Discussion The WSJ results shown in Tables 2 and 3 suggest that discriminative models incorporating both non- local and local lexical and syntactic information can achieve good results on the task of non-local dependency identification . 
	</s>
	

	<s id="134">
		 On the PARSEVAL metric , our algorithm performed particularly well on null complementizer and control locus insertion , and on S node relocation . 
	</s>
	

	<s id="135">
		 In particular , Johnson noted that the proper insertion of control loci was a difficult issue involving lexical as well as structural sensitivity . 
	</s>
	

	<s id="136">
		 We found the loglinear paradigm a good one in which to model this feature combination ; when run in isolation on gold-standard development trees , our model reached 96.4 % F 1 on control locus insertion , reducing error over the Johnson model’s 89.3 % 14 Many head-dependent relations in NEGRA are explicitly marked , but for those that are not we used a Collins (1999)- style head-finding algorithm independently developed for German PCFG parsing . 
	</s>
	

	<s id="137">
		 PCF P AoP G AoG 76.3 75.4 75.7 98.7 99.7 76.3 75.4 75.7 98.7 99.6 62.0 59.3 61.0 90.9 93.6 Table 5 : Typed dependency F1 performance when composed with statistical parser . 
	</s>
	

	<s id="138">
		 Remapped dependencies involve only non-relativization dislocations and exclude control loci . 
	</s>
	

	<s id="139">
		 by nearly two-thirds . 
	</s>
	

	<s id="140">
		 The performance of our algorithm is also evident in the substantial contribution to typed dependency accuracy seen in Table 3 . 
	</s>
	

	<s id="141">
		 For gold-standard input trees , our algorithm reduces error by over 80 % from the surface-dependency baseline , and over 60 % compared with Johnson’s results . 
	</s>
	

	<s id="142">
		 For parsed input trees , our algorithm reduces dependency error by 23 % over the baseline , and by 5 % compared with Johnson’s results . 
	</s>
	

	<s id="143">
		 Note that the dependency figures of Dienes lag behind even the parsed results for Johnson’s model ; this may well be due to the fact that Dienes built his model as an extension of 
		<ref citStr="Collins ( 1999 )" id="32" label="CJPN" position="31851">
			Collins ( 1999 )
		</ref>
		 , which lags behind 
		<ref citStr="Charniak ( 2000 )" id="33" label="CEPF" position="31889">
			Charniak ( 2000 )
		</ref>
		 by about 1.3-1.5 % . 
	</s>
	

	<s id="144">
		 Manual investigation of errors on English gold- standard data revealed two major issues that suggest further potential for improvement in performance without further increase in algorithmic complexity or training set size . 
	</s>
	

	<s id="145">
		 First , we noted that annotation inconsistency accounted for a large number of errors , particularly false positives . 
	</s>
	

	<s id="146">
		 VPs from which an S has been extracted ( [ SShut up , ] he [ VP said t ] ) are inconsistently given an empty SBAR daughter , suggesting the cross-model low-70’s performance on null SBAR insertion models ( see Table 2 ) may be a ceiling . 
	</s>
	

	<s id="147">
		 Control loci were often under-annotated ; the first five development-set false positive control loci we checked were all due to annotation error . 
	</s>
	

	<s id="148">
		 And why-WHADVPs under SBAR , which are always dislocations , were not so annotated 20 % of the time . 
	</s>
	

	<s id="149">
		 Second , both control locus insertion and dislocated NP remapping must be sensitive to the presence of argument NPs under classified nodes . 
	</s>
	

	<s id="150">
		 But temporal NPs , indistinguishable by gross category , also appear under such nodes , creating a major confound . 
	</s>
	

	<s id="151">
		 We used customized features to compensate to some extent , but temporal annotation already exists in WSJ and could be used . 
	</s>
	

	<s id="152">
		 We note that 
		<ref citStr="Klein and Manning ( 2003 )" id="34" label="CEPF" position="33244">
			Klein and Manning ( 2003 )
		</ref>
		 independently found retention of temporal NP marking useful for PCFG parsing . 
	</s>
	

	<s id="153">
		 As can be seen in Table 3 , the absolute improvement in dependency recovery is smaller for both our and Johnson’s postprocessing algorithms when applied to parsed input trees than when applied to gold-standard input trees . 
	</s>
	

	<s id="154">
		 It seems that this degradation is not primarily due to noise in parse tree out puts reducing recall of nonlocal dependency identification : precision/recall splits were largely the same between gold and parsed data , and manual inspection revealed that incorrect nonlocal dependency choices often arose from syntactically reasonable yet incorrect input from the parser . 
	</s>
	

	<s id="155">
		 For example , the gold-standard parse right-wing whites ... will [ VP step up [ NP their threats [ S [ VP * to take matters into their own hands ] ] ] ] has an unindexed control locus because Treebank annotation specifies that infinitival VPs inside NPs are not assigned controllers . 
	</s>
	

	<s id="156">
		 Charniak’s parser , however , attaches the infinitival VP into the higher step up ... 
	</s>
	

	<s id="157">
		 VP . 
	</s>
	

	<s id="158">
		 Infinitival VPs inside VPs generally do receive controllers for their null subjects , and our algorithm accordingly yet mistakenly assigns right-wing-whites as the antecedent . 
	</s>
	

	<s id="159">
		 The English/German comparison shown in Tables 4 and 5 is suggestive , but caution is necessary in its interpretation due to the fact that differences in both language structure and treebank annotation may be involved . 
	</s>
	

	<s id="160">
		 Results in the G column of Table 5 , showing the accuracy of the context-free dependency approximation from gold-standard parse trees , quantitatively corroborates the intuition that nonlocal dependency is more prominent in German than in English . 
	</s>
	

	<s id="161">
		 Manual investigation of errors made on German gold-standard data revealed two major sources of error beyond sparsity . 
	</s>
	

	<s id="162">
		 The first was a widespread ambiguity of S and VP nodes within S and VP nodes ; many true dislocations of all sorts are expressed at the S and VP levels in CFG parse trees , such as VP- 1 of Figure 2 , but many adverbial and subordinate phrases of S or VP category are genuine dependents of the main clausal verb . 
	</s>
	

	<s id="163">
		 We were able to find a number of features to distinguish some cases , such as the presence of certain unambiguous relative- clause introducing complementizers beginning an S node , but much ambiguity remained . 
	</s>
	

	<s id="164">
		 The second was the ambiguity that some matrix S-initial NPs are actually dependents of the VP head ( in these cases , NEGRA annotates the finite verb as the head of S and the non-finite verb as the head of VP ) . 
	</s>
	

	<s id="165">
		 This is not necessarily a genuine discontinuity per se , but rather corresponds to identification of the subject NP in a clause . 
	</s>
	

	<s id="166">
		 Obviously , having access to reliable case marking would improve performance in this area ; such information is in fact included in NEGRA’s morphological annotation , another argument for the utility of involving enhanced annotation in CF parsing . 
	</s>
	

	<s id="167">
		 As can be seen in the right half of Table 4 , performance falls off considerably on vanilla PCFG- WSJ(full) WSJ(sm) NEGRA parsed data . 
	</s>
	

	<s id="168">
		 This fall-off seems more dramatic than that seen in Sections 4.1 and 4.2 , no doubt partly due to the poorer performance of the vanilla PCFG , but likely also because only non-relativization dislocations are considered in Section 4.3 . 
	</s>
	

	<s id="169">
		 These dislocations often require non-local information ( such as identity of surface lexical governor ) for identification and are thus especially susceptible to degradation in parsed data . 
	</s>
	

	<s id="170">
		 Nevertheless , seemingly dismal performance here still provided a strong boost to typed dependency evaluation of parsed data , as seen in A o P of Table 5 . 
	</s>
	

	<s id="171">
		 We suspect this indicates that dislocated terminals are being usefully identified and mapped back to their proper governors , even if the syntactic projections of these terminals and governors are not being correctly identified by the parser . 
	</s>
	

	<s id="172">
		 6 Further Work Against the background of CFG as the standard approximation of dependency structure for broad- coverage parsing , there are essentially three options for the recovery of nonlocal dependency . 
	</s>
	

	<s id="173">
		 The first option is to postprocess CF parse trees , which we have closely investigated in this paper . 
	</s>
	

	<s id="174">
		 The second is to incorporate nonlocal dependency information into the category structure of CF trees . 
	</s>
	

	<s id="175">
		 This was the approach taken by Dienes and Dubey ( 2003a,b ) and 
		<ref citStr="Dienes ( 2003 )" id="35" label="CEPF" position="37842">
			Dienes ( 2003 )
		</ref>
		 ; it is also practiced in recent work on broad-coverage CCG parsing 
		<ref citStr="Hockenmaier , 2003" id="36" label="CEPF" position="37933">
			( Hockenmaier , 2003 )
		</ref>
		 . 
	</s>
	

	<s id="176">
		 The third would be to incorporate nonlocal dependency information into the edge structure parse trees , allowing discontinuous constituency to be explicitly represented in the parse chart . 
	</s>
	

	<s id="177">
		 This approach was tentatively investigated by 
		<ref citStr="Plaehn ( 2000 )" id="37" label="CEPF" position="38205">
			Plaehn ( 2000 )
		</ref>
		 . 
	</s>
	

	<s id="178">
		 As the syntactic diversity of languages for which treebanks are available grows , it will become increasingly important to compare these three approaches . 
	</s>
	

	<s id="179">
		 7 Acknowledgements This work has benefited from feedback from Dan Jurafsky and three anonymous reviewers , and from presentation at the Institute of Cognitive Science , University of Colorado at Boulder . 
	</s>
	

	<s id="180">
		 The authors are also grateful to Dan Klein and Jenny Finkel for use of maximum-entropy software they wrote . 
	</s>
	

	<s id="181">
		 This work was supported in part by the Advanced Research and Development Activity (ARDA)’s Advanced Question Answering for Intelligence ( AQUAINT ) Program . 
	</s>
	

	<s id="182">
		 References Charniak , E. ( 2000 ) . 
	</s>
	

	<s id="183">
		 A Maximum-Entropy-inspired parser . 
	</s>
	

	<s id="184">
		 In Proceedings ofNAACL . 
	</s>
	

	<s id="185">
		 Chomsky , N. ( 1956 ) . 
	</s>
	

	<s id="186">
		 Three models for the description of language . 
	</s>
	

	<s id="187">
		 IRE Transactions on Information Theory , 2(3):113– 124 . 
	</s>
	

	<s id="188">
		 Collins , M. ( 1999 ) . 
	</s>
	

	<s id="189">
		 Head-Driven Statistical Models forNatural Language Parsing . 
	</s>
	

	<s id="190">
		 PhD thesis , University of Pennsylvania . 
	</s>
	

	<s id="191">
		 Dienes , P. ( 2003 ) . 
	</s>
	

	<s id="192">
		 Statistical Parsing with Non-local Depen- dencies . 
	</s>
	

	<s id="193">
		 PhD thesis , Saarland University . 
	</s>
	

	<s id="194">
		 Dienes , P. and Dubey , A. ( 2003a ) . 
	</s>
	

	<s id="195">
		 Antecedent recovery : Ex- periments with a trace tagger . 
	</s>
	

	<s id="196">
		 In Proceedings ofEMNLP . 
	</s>
	

	<s id="197">
		 Dienes , P. and Dubey , A. ( 2003b ) . 
	</s>
	

	<s id="198">
		 Deep processing by com- bining shallow methods . 
	</s>
	

	<s id="199">
		 In Proceedings ofACL . 
	</s>
	

	<s id="200">
		 Dubey , A. and Keller , F. ( 2003 ) . 
	</s>
	

	<s id="201">
		 Parsing German with sister- head dependencies . 
	</s>
	

	<s id="202">
		 In Proceedings ofACL . 
	</s>
	

	<s id="203">
		 Gazdar , G. , Klein , E. , Pullum , G. , and Sag , I. ( 1985 ) . 
	</s>
	

	<s id="204">
		 Generalized Phrase Structure Grammar . 
	</s>
	

	<s id="205">
		 Harvard . 
	</s>
	

	<s id="206">
		 Gildea , D. and Jurafsky , D. ( 2002 ) . 
	</s>
	

	<s id="207">
		 Automatic labeling of se- mantic roles . 
	</s>
	

	<s id="208">
		 Computational Linguistics , 28(3):245–288 . 
	</s>
	

	<s id="209">
		 Hockenmaier , J. ( 2003 ) . 
	</s>
	

	<s id="210">
		 Data and models for Statistical Parsing with Combinatory Categorial Grammar . 
	</s>
	

	<s id="211">
		 PhD thesis , University of Edinburgh . 
	</s>
	

	<s id="212">
		 Johnson , M. ( 2002 ) . 
	</s>
	

	<s id="213">
		 A simple pattern-matching algorithm for recovering empty nodes and their antecedents . 
	</s>
	

	<s id="214">
		 In Proceedings ofACL , volume 40 . 
	</s>
	

	<s id="215">
		 Kaplan , R. , Riezler , S. , King , T. H. , Maxwell , J. T. , Vasserman , A. , and Crouch , R. ( 2004 ) . 
	</s>
	

	<s id="216">
		 Speed and accuracy in shallow and deep stochastic parsing . 
	</s>
	

	<s id="217">
		 In Proceedings ofNAACL . 
	</s>
	

	<s id="218">
		 Kaplan , R. M. and Maxwell , J. T. ( 1993 ) . 
	</s>
	

	<s id="219">
		 The interface between phrasal and functional constraints . 
	</s>
	

	<s id="220">
		 Computational Linguistics , 19(4):571–590 . 
	</s>
	

	<s id="221">
		 Klein , D. and Manning , C. D. ( 2003 ) . 
	</s>
	

	<s id="222">
		 Accurate unlexicalized parsing . 
	</s>
	

	<s id="223">
		 In Proceedings ofACL . 
	</s>
	

	<s id="224">
		 Kruijff , G.-J. ( 2002 ) . 
	</s>
	

	<s id="225">
		 Learning linearization rules from treebanks . 
	</s>
	

	<s id="226">
		 Invited talk at the Formal Grammar’02/COLOGNET-ELSNET Symposium . 
	</s>
	

	<s id="227">
		 Levy , R. ( 2004 ) . 
	</s>
	

	<s id="228">
		 Probabilistic Models of Syntactic Discontinuity . 
	</s>
	

	<s id="229">
		 PhD thesis , Stanford University . 
	</s>
	

	<s id="230">
		 In progress . 
	</s>
	

	<s id="231">
		 Maxwell , J. T. and Manning , C. D. ( 1996 ) . 
	</s>
	

	<s id="232">
		 A theory of non- constituent coordination based on finite-state rules . 
	</s>
	

	<s id="233">
		 In Butt , M. and King , T. H. , editors , Proceedings ofLFG . 
	</s>
	

	<s id="234">
		 Pasca , M. and Harabagiu , S. M. ( 2001 ) . 
	</s>
	

	<s id="235">
		 High performance question/answering . 
	</s>
	

	<s id="236">
		 In Proceedings of SIGIR . 
	</s>
	

	<s id="237">
		 Plaehn , O. ( 2000 ) . 
	</s>
	

	<s id="238">
		 Computing the most probable parse for a discontinuous phrase structure grammar . 
	</s>
	

	<s id="239">
		 In Proceedings of IWPT , Trento , Italy . 
	</s>
	

	<s id="240">
		 Riezler , S. , King , T. H. , Kaplan , R. M. , Crouch , R. S. , Maxwell , J. T. , and Johnson , M. ( 2002 ) . 
	</s>
	

	<s id="241">
		 Parsing the Wall Street Journal using a Lexical-Functional Grammar and discriminative estimation techniques . 
	</s>
	

	<s id="242">
		 In Proceedings ofACL , pages 271– 278 . 
	</s>
	

	<s id="243">
		 Skut , W. , Brants , T. , Krenn , B. , and Uszkoreit , H. ( 1997a ) . 
	</s>
	

	<s id="244">
		 Annotating unrestricted German text . 
	</s>
	

	<s id="245">
		 In Fachtagung der Sektion Computerlinguistik der Deutschen Gesellschaft fr Sprachwissenschaft , Heidelberg , Germany . 
	</s>
	

	<s id="246">
		 Skut , W. , Krenn , B. , Brants , T. , and Uszkoreit , H. ( 1997b ) . 
	</s>
	

	<s id="247">
		 An annotation scheme for free word order languages . 
	</s>
	

	<s id="248">
		 In Proceedings ofANLP . 
	</s>
	


</acldoc>
