<?xml version="1.0" encoding="iso-8859-1"?>
<acldoc acl_id="P04-1052">
	

	<s id="1">
		 Generating Referring Expressions in Open Domains Advaith Siddharthan Ann Copestake Computer Science Department Computer Laboratory Columbia University University of Cambridge as372@cs.columbia.edu aac10@cl.cam.ac.uk Abstract We present an algorithm for generating referring expressions in open domains . 
	</s>
	

	<s id="2">
		 Existing algorithms work at the semantic level and assume the availability of a classification for attributes , which is only feasible for restricted domains . 
	</s>
	

	<s id="3">
		 Our alternative works at the realisation level , relies on Word- Net synonym and antonym sets , and gives equivalent results on the examples cited in the literature and improved results for examples that prior approaches cannot handle . 
	</s>
	

	<s id="4">
		 We believe that ours is also the first algorithm that allows for the incremental incorporation of relations . 
	</s>
	

	<s id="5">
		 We present a novel corpus-evaluation using referring expressions from the Penn Wall Street Journal Treebank . 
	</s>
	

	<s id="6">
		 1 Introduction Referring expression generation has historically been treated as a part of the wider issue of generating text from an underlying semantic representation . 
	</s>
	

	<s id="7">
		 The task has therefore traditionally been approached at the semantic level . 
	</s>
	

	<s id="8">
		 Entities in the real world are logically represented ; for example ( ignoring quantifiers ) , a big brown dog might be repre- sented as big1 ( x ) n brown1 ( x ) n dog1 ( x ) , where the predicates big1 , brown1 and dog1 represent different attributes of the variable ( entity ) x . 
	</s>
	

	<s id="9">
		 The task of referring expression generation has traditionally been framed as the identification of the shortest logical description for the referent entity that differentiates it from all other entities in the discourse domain . 
	</s>
	

	<s id="10">
		 For example , if there were a small brown dog ( small1 ( x ) n brown1 ( x ) n dog1 ( x ) ) in context , the minimal description for the big brown dog would be big1 ( x ) n dog1 (x)1 . 
	</s>
	

	<s id="11">
		 This semantic framework makes it difficult to apply existing referring expression generation algorithms to the many regeneration tasks that are important today ; for example , summarisation , open- ended question answering and text simplification . 
	</s>
	

	<s id="12">
		 Unlike in traditional generation , the starting point in ' The predicate dog1 is selected because it has a distin- guished status , referred to as type in 
		<ref citStr="Reiter and Dale ( 1992 )" id="1" label="CEPF" position="2396">
			Reiter and Dale ( 1992 )
		</ref>
		 . 
	</s>
	

	<s id="13">
		 One such predicate has to to be present in the description . 
	</s>
	

	<s id="14">
		 these tasks is unrestricted text , rather than a semantic representation of a small domain . 
	</s>
	

	<s id="15">
		 It is difficult to extract the required semantics from unrestricted text ( this task would require sense disambiguation , among other issues ) and even harder to construct a classification for the extracted predicates in the manner that existing approaches require ( cf. , § 2 ) . 
	</s>
	

	<s id="16">
		 In this paper , we present an algorithm for generating referring expressions in open domains . 
	</s>
	

	<s id="17">
		 We discuss the literature and detail the problems in applying existing approaches to reference generation to open domains in § 2 . 
	</s>
	

	<s id="18">
		 We then present our approach in § 3 , contrasting it with existing approaches . 
	</s>
	

	<s id="19">
		 We extend our approach to handle relations in § 3.3 and present a novel corpus-based evaluation on the Penn WSJ Treebank in § 4 . 
	</s>
	

	<s id="20">
		 2 Overview of Prior Approaches The incremental algorithm 
		<ref citStr="Reiter and Dale , 1992" id="2" label="CEPF" position="3430">
			( Reiter and Dale , 1992 )
		</ref>
		 is the most widely discussed attribute selection algorithm . 
	</s>
	

	<s id="21">
		 It takes as input the intended referent and a contrast set of distractors ( other entities that could be confused with the intended referent ) . 
	</s>
	

	<s id="22">
		 Entities are represented as attribute value matrices ( AVMs ) . 
	</s>
	

	<s id="23">
		 The algorithm also takes as input a *preferred-attributes* list that contains , in order of preference , the attributes that human writers use to reference objects . 
	</s>
	

	<s id="24">
		 For example , the preference might be { colour , size , shape ... } . 
	</s>
	

	<s id="25">
		 The algorithm then repeatedly selects attributes from *preferred- attributes* that rule out at least one entity in the contrast set until all distractors have been ruled out . 
	</s>
	

	<s id="26">
		 It is instructive to look at how the incremental algorithm works . 
	</s>
	

	<s id="27">
		 Consider an example where a large brown dog needs to be referred to . 
	</s>
	

	<s id="28">
		 The contrast set contains a large black dog . 
	</s>
	

	<s id="29">
		 These are represented by the AVMs shown below . 
	</s>
	

	<s id="30">
		 ~ ~ type dog ~size large ~ colour black Assuming that the *preferred-attributes* list is [ size , colour , ... ] , the algorithm would first com- pare the values of the size attribute ( both large ) , type dog size large colour brown ~ ~ 1 disregard that attribute as not being discriminating , compare the values of the colour attribute and return the brown dog . 
	</s>
	

	<s id="31">
		 Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation ( the dog that is not black ) and references to multiple entities ( the brown or black dogs ) ( van Deemter , 2002 ) , explored different search algorithms for finding the minimal description ( e.g. , 
		<ref citStr="Horacek ( 2003 )" id="3" label="CJPN" position="5142">
			Horacek ( 2003 )
		</ref>
		 ) and offered different representation frameworks like graph theory 
		<ref citStr="Krahmer et al. , 2003" id="4" label="CJPN" position="5236">
			( Krahmer et al. , 2003 )
		</ref>
		 as alternatives to AVMs . 
	</s>
	

	<s id="32">
		 However , all these approaches are based on very similar formalisations of the problem , and all make the following assumptions : 1 . 
	</s>
	

	<s id="33">
		 A semantic representation exists . 
	</s>
	

	<s id="34">
		 2. A classification scheme for attributes exists . 
	</s>
	

	<s id="35">
		 3. The linguistic realisations are unambiguous . 
	</s>
	

	<s id="36">
		 Attributes cannot be reference modifying . 
	</s>
	

	<s id="37">
		 All these assumptions are violated when we move from generation in a very restricted domain to regeneration in an open domain . 
	</s>
	

	<s id="38">
		 In regeneration tasks such as summarisation , open-ended question answering and text simplification , AVMs for entities are typically constructed from noun phrases , with the head noun as the type and pre-modifiers as attributes . 
	</s>
	

	<s id="39">
		 Converting words into semantic labels would involve sense disambiguation , adding to the cost and complexity of the analysis module . 
	</s>
	

	<s id="40">
		 Also , attribute classification is a hard problem and there is no existing classification scheme that can be used for open domains like newswire ; for example , WordNet 
		<ref citStr="Miller et al. , 1993" id="5" label="OEPF" position="6342">
			( Miller et al. , 1993 )
		</ref>
		 organises adjectives as concepts that are related by the non-hierarchical relations of synonymy and antonymy ( unlike nouns that are related through hierarchical links such as hyponymy , hypernymy and metonymy ) . 
	</s>
	

	<s id="41">
		 In addition , selecting attributes at the semantic level is risky because their linguistic realisation might be ambiguous and many common adjectives are polysemous ( cf. , example 1 in § 3.1 ) . 
	</s>
	

	<s id="42">
		 Reference modification , which has not been considered in the referring expression generation literature , raises further issues ; for example , referring to an alleged murderer as the murderer is potentially libellous . 
	</s>
	

	<s id="43">
		 In addition to the above , there is the issue of overlap between values of attributes . 
	</s>
	

	<s id="44">
		 The case of subsumption ( for example , that the colour red subsumes crimson and the type dog subsumes chihuahua ) has received formal treatment in the literature ; 
		<ref citStr="Dale and Reiter ( 1995 )" id="6" label="CJPN" position="7287">
			Dale and Reiter ( 1995 )
		</ref>
		 provide a find-bestvalue function that evaluates tree-like hierarchies of values . 
	</s>
	

	<s id="45">
		 As mentioned earlier , such hierarchical knowledge bases do not exist for open domains . 
	</s>
	

	<s id="46">
		 Further , a treatment of subsumption is insufficient , and degrees of intersection between attribute values also require consideration . 
	</s>
	

	<s id="47">
		 van 
		<ref citStr="Deemter ( 2000 )" id="7" label="CJPN" position="7644">
			Deemter ( 2000 )
		</ref>
		 discusses the generation of vague descriptions when entities have gradable attributes like size ; for example , in a domain with four mice sized 2 , 5 , 7 and 10cm , it is possible to refer to the large mouse ( the mouse sized 10cm ) or the two small mice ( the mice sized 2 and 5cm ) . 
	</s>
	

	<s id="48">
		 However , when applying referring expression generation to regeneration tasks where the representation of entities is derived from text rather than a knowledge base , we have to consider the case where the grading of attributes is not explicit . 
	</s>
	

	<s id="49">
		 For example , we might need to compare the attribute dark with black , light or white . 
	</s>
	

	<s id="50">
		 In contrast to previous approaches , our algorithm works at the level of words , not semantic labels , and measures the relatedness of adjectives ( lexicalised attributes ) using the lexical knowledge base Word- Net rather than a semantic classification . 
	</s>
	

	<s id="51">
		 Our approach also addresses the issue of comparing intersective attributes that are not explicitly graded , by making novel use of the synonymy and antonymy links in WordNet . 
	</s>
	

	<s id="52">
		 Further , it treats discriminating power as only one criteria for selecting attributes and allows for the easy incorporation of other considerations such as reference modification ( § 5 ) . 
	</s>
	

	<s id="53">
		 3 The Lexicalised Approach 3.1 Quantifying Discriminating Power We define the following three quotients . 
	</s>
	

	<s id="54">
		 Similarity Quotient ( 5Q ) We define similarity as transitive synonymy . 
	</s>
	

	<s id="55">
		 The idea is that if X is a synonym of Y and Y is a synonym of Z , then X is likely to be similar to Z . 
	</s>
	

	<s id="56">
		 The degree of similarity between two adjectives depends on how many steps must be made through WordNet synonymy lists to get from one to the other . 
	</s>
	

	<s id="57">
		 Suppose we need to find a referring expression for e0 . 
	</s>
	

	<s id="58">
		 For each adjective aj describing e0 , we calculate a similarity quotient 5Qj by initialising it to 0 , forming a set of WordNet synonyms 51 of aj , forming a synonymy set 52 containing all the Word- Net synonyms of all the adjectives in 51 and forming 53 from 52 similarly . 
	</s>
	

	<s id="59">
		 Now for each adjective describing any distractor , we increment 5Qj by 4 if it is present in 51 , by 2 if it is present in 52 , and by 1 if it is present in 53 . 
	</s>
	

	<s id="60">
		 5Qj now measures how similar aj is to other adjectives describing distractors . 
	</s>
	

	<s id="61">
		 Contrastive Quotient ( CQ ) Similarly , we define contrastive in terms of antonymy relationships . 
	</s>
	

	<s id="62">
		 We form the set C1 of strict WordNet antonyms of aj . 
	</s>
	

	<s id="63">
		 The set C2 con- sists of strict WordNet antonyms of members of 51 and WordNet synonyms of members of C1 . 
	</s>
	

	<s id="64">
		 C3 is similarly constructed from 52 and C2 . 
	</s>
	

	<s id="65">
		 We now initialise CQj to zero and for each adjective describing each distractor , we add w =E { 4,2 , 1 } to CQj , depending on whether it is a member of C1 , C2 or C3 . 
	</s>
	

	<s id="66">
		 CQj now measures how contrasting aj is to other adjectives describing distractors . 
	</s>
	

	<s id="67">
		 Discriminating Quotient ( DQ ) An attribute that has a high value of 5Q has bad discriminating power . 
	</s>
	

	<s id="68">
		 An attribute that has a high value of CQ has good discriminating power . 
	</s>
	

	<s id="69">
		 We can now define the Discriminating Quotient ( DQ ) as DQ = CQ ^ 5Q . 
	</s>
	

	<s id="70">
		 We now have an order ( decreasing DQs ) in which to incorporate attributes . 
	</s>
	

	<s id="71">
		 This constitutes our *preferred* list . 
	</s>
	

	<s id="72">
		 We illustrate the benefits of our approach with two examples . 
	</s>
	

	<s id="73">
		 Example 1 : The Importance of Lexicalisation Previous referring expression generation algorithms ignore the issue of realising the logical description for the referent . 
	</s>
	

	<s id="74">
		 The semantic labels are chosen such that they have a direct correspondence with their linguistic realisation and the realisation is thus considered trivial . 
	</s>
	

	<s id="75">
		 Ambiguity and syntactically optional arguments are ignored . 
	</s>
	

	<s id="76">
		 To illustrate one problem this causes , consider the two entities below : e1 e2 type president age young tenure past If we followed the strict typing system used by previous algorithms , with *preferred*={age , tenure } , to refer to e1 we would compare the age attributes and rule out e2 and generate the old president . 
	</s>
	

	<s id="77">
		 This expression is ambiguous since old can also mean previous . 
	</s>
	

	<s id="78">
		 Models that select attributes at the semantic level will run into trouble when their linguistic realisations are ambiguous . 
	</s>
	

	<s id="79">
		 In contrast , our algorithm , given flattened attribute lists : e1 e2 r head president II head president 1 L attrib old , current J L attrib young , past J successfully picks the current president as current has a higher DQ ( 2 ) than old ( 0 ) : attribute distractor CQ SQ DQ old current e 2 { young , past } e 2 { young , past } 4 4 0 2 0 2 In this example , old is a WordNet antonym of young and a WordNet synonym of past . 
	</s>
	

	<s id="80">
		 Current is a WordNet synonym of present , which is a WordNet antonym of past . 
	</s>
	

	<s id="81">
		 Note that WordNet synonym and antonym links capture the implicit gradation in the lexicalised values of the age and tenure attributes . 
	</s>
	

	<s id="82">
		 Example 2 : Naive Incrementality To illustrate another problem with the original incremental algorithm , consider three dogs : e 1(a big black dog ) , e 2 ( a small black dog ) and e 3 ( a tiny white dog ) . 
	</s>
	

	<s id="83">
		 Consider using the original incremental algorithm to refer to e1 with *preferred*={colour , size } . 
	</s>
	

	<s id="84">
		 The colour attribute black rules out e3 . 
	</s>
	

	<s id="85">
		 We then we have to select the size attribute big as well to rule out e2 , thus generating the sub-optimal expression the big black dog . 
	</s>
	

	<s id="86">
		 Here , the use of a predetermined *preferred* list fails to capture what is obvious from the context : that e 1 stands out not because it is black , but because it is big . 
	</s>
	

	<s id="87">
		 In our approach , for each of e 1’s attributes , we calculate DQ with respect to e 2 and e 3 : attribute distractor CQ SQ DQ big e2{small , black } 4 0 4 big e 3 { tiny , white } 2 0 2 black e2{small , black } 1 4 -3 black e 3 { tiny , white } 2 1 1 Overall , big has a higher discriminating power ( 6 ) than black ( -2 ) and rules out both e 2 and e 3 . 
	</s>
	

	<s id="88">
		 We therefore generate the big dog . 
	</s>
	

	<s id="89">
		 Our incremental approach thus manages to select the attribute that stands out in context . 
	</s>
	

	<s id="90">
		 This is because we construct the *preferred* list after observing the context . 
	</s>
	

	<s id="91">
		 We discuss this issue further in the next section . 
	</s>
	

	<s id="92">
		 Note again that WordNet antonym and synonym links capture the gradation in the lexicalised size and colour attributes . 
	</s>
	

	<s id="93">
		 However , this only works where the gradation is along one axis ; in particular , this approach will not work for colours in general , and cannot be used to deduce the relative similarity between yellow and orange as compared to , say , yellow and blue . 
	</s>
	

	<s id="94">
		 3.2 Justifying our Algorithm The psycholinguistic justification for the incremental algorithm ( IA ) hinges on two premises : 1 . 
	</s>
	

	<s id="95">
		 Humans build referring expressions incrementally . 
	</s>
	

	<s id="96">
		 2. There is a preferred order in which humans select attributes ( e.g. , colour&gt;shape&gt; size ... ) . 
	</s>
	

	<s id="97">
		 Our algorithm is also incremental . 
	</s>
	

	<s id="98">
		 However , it departs significantly from premise 2 . 
	</s>
	

	<s id="99">
		 We assume that speakers pick out attributes that are distinctive in context ( cf. , example 2 , previous section ) . 
	</s>
	

	<s id="100">
		 Averaged over contexts , some attributes have more discriminating power than others ( largely because of the way we visualise entities ) and premise 2 is an approximation to our approach . 
	</s>
	

	<s id="101">
		 We now quantify the extra effort we are making to identify attributes that “stand out” in a given context . 
	</s>
	

	<s id="102">
		 Let N be the maximum number of entities in type president age old tenure current ~ ~ 1[ the contrast set and n be the maximum number of attributes per entity . 
	</s>
	

	<s id="103">
		 The table below compares the computational complexity of an optimal algorithm ( such as 
		<ref citStr="Reiter ( 1990 )" id="8" label="CEPF" position="15630">
			Reiter ( 1990 )
		</ref>
		 ) , our algorithm and the IA . 
	</s>
	

	<s id="104">
		 Incremental Algo Our Algorithm Optimal Algo O(nN) O(n2N) O(n2 N ) Both the IA and our algorithm are linear in the number of entities N . 
	</s>
	

	<s id="105">
		 This is because neither algorithm allows backtracking ; an attribute , once selected , cannot be discarded . 
	</s>
	

	<s id="106">
		 In contrast , an optimal search requires O(2N) comparisons . 
	</s>
	

	<s id="107">
		 As our algorithm compares each attribute of the discourse referent to every attribute of every distractor , it is quadratic in n . 
	</s>
	

	<s id="108">
		 The IA compares each attribute of the discourse referent to only one attribute per distractor and is linear in n . 
	</s>
	

	<s id="109">
		 Note , however , that values for n of over 4 are rare . 
	</s>
	

	<s id="110">
		 3.3 Relations Semantically , attributes describe an entity ( e.g. , the small grey dog ) and relations relate an entity to other entities ( e.g. , the dog in the bin ) . 
	</s>
	

	<s id="111">
		 Relations are troublesome because in relating an entity e , , to el , we need to recursively generate a referring expression for el . 
	</s>
	

	<s id="112">
		 The IA does not consider relations and the referring expression is constructed out of attributes alone . 
	</s>
	

	<s id="113">
		 The 
		<ref citStr="Dale and Haddock ( 1991 )" id="9" label="CJPN" position="16799">
			Dale and Haddock ( 1991 )
		</ref>
		 algorithm allows for relational descriptions but involves exponential global search , or a greedy search approximation . 
	</s>
	

	<s id="114">
		 To incorporate relational descriptions in the incremental framework would require a classification system which somehow takes into account the relations themselves and the secondary entities el etc. . 
	</s>
	

	<s id="115">
		 This again suggests that the existing algorithms force the incrementality at the wrong stage in the generation process . 
	</s>
	

	<s id="116">
		 Our approach computes the order in which attributes are incorporated after observing the context , by quantifying their utility through the quotient DQ . 
	</s>
	

	<s id="117">
		 This makes it easy for us to extend our algorithm to handle relations , because we can compute DQ for relations in much the same way as we did for attributes.We illustrate this for prepositions . 
	</s>
	

	<s id="118">
		 3.4 Calculating DQ for Relations Suppose the referent entity eref contains a relation [ prep , , e , , ] that we need to calculate the three quotients for ( cf. , figure 1 for representation of relations in AVMs ) . 
	</s>
	

	<s id="119">
		 We consider each entity ez in the contrast set for eref in turn . 
	</s>
	

	<s id="120">
		 If ez does not have a prep , , relation then the relation is useful and we increment CQ by 4 . 
	</s>
	

	<s id="121">
		 If ez has a prep , , relation then two cases arise . 
	</s>
	

	<s id="122">
		 If the object of ez’s prep , , relation is e , , then we increment 5Q by 4 . 
	</s>
	

	<s id="123">
		 If it is not e , , , the relation is useful and we increment CQ by 4 . 
	</s>
	

	<s id="124">
		 This is an efficient non-recursive way of computing the quotients CQ and 5Q for relations . 
	</s>
	

	<s id="125">
		 We now discuss how to calculate DQ . 
	</s>
	

	<s id="126">
		 For attributes , we defined DQ = CQ — 5Q . 
	</s>
	

	<s id="127">
		 However , as the linguistic realisation of a relation is a phrase and not a word , we would like to normalise the discriminating power of a relation with the length of its linguistic realisation . 
	</s>
	

	<s id="128">
		 Calculating the length involves recursively generating referring expressions for the object of the preposition , an expensive task that we want to avoid unless we are actually using that relation in the final referring expression . 
	</s>
	

	<s id="129">
		 We therefore initially approximate the length as follows . 
	</s>
	

	<s id="130">
		 The realisation of a relation [ prep , , e , , ] consists of prep , , , a determiner and the referring expression for e , , . 
	</s>
	

	<s id="131">
		 If none of eref’s distractors have a prep , , relation then we only require the head noun of e , , in the referring expression and length = 3 . 
	</s>
	

	<s id="132">
		 In this case , the relation is sufficient to identify both entities ; for example , even if there were multiple bins in figure 1 , as long as only one dog is in a bin , the reference the dog in the bin succeeds in uniquely referencing both the dog and the bin . 
	</s>
	

	<s id="133">
		 If n distractors of eref contain a prep , , relation with a non-e , , object that is distractor for e , , , we set length = 3 + n . 
	</s>
	

	<s id="134">
		 This is an estimate for the word length of the realised relation that assumes one extra attribute for distinguishing e , , from each distractor . 
	</s>
	

	<s id="135">
		 Normalisation by estimated length is vital ; if e , , requires a long description , the relations’s DQ should be small so that shorter possibilities are considered first in the incremental process . 
	</s>
	

	<s id="136">
		 The formula for DQ for relations is therefore DQ = ( CQ — 5Q)/length . 
	</s>
	

	<s id="137">
		 This approach can also be extended to allow for relations such as comparatives which have syntactically optional arguments ( e.g. , the earlier flight vs the flight earlier than UA941 ) which are not allowed for by approaches which ignore realisation . 
	</s>
	

	<s id="138">
		 3.5 The Lexicalised Context-Sensitive IA Our lexicalised context-sensitive incremental algorithm ( below ) generates a referring expression for Entity . 
	</s>
	

	<s id="139">
		 As it recurses , it keeps track of entities it has used up in order to avoid entering loops like the dog in the bin containing the dog in the bin .... To generate a referring expression for an entity , the algorithm calculates the DQs for all its attributes and approximates the DQs for all its relations ( 2 ) . 
	</s>
	

	<s id="140">
		 It then forms the *preferred* list ( 3 ) and constructs the referring expression by adding elements of *preferred* till the contrast set is empty ( 4 ) . 
	</s>
	

	<s id="141">
		 This is straightforward for attributes ( 5 ) . 
	</s>
	

	<s id="142">
		 For relations ( 6 ) , it needs to recursively generate the prepositional phrase first . 
	</s>
	

	<s id="143">
		 It checks that it hasn’t entered a loop ( 6a ) , generates a new contrast set for the object of the relation (6(a)i) , recursively generates a referring expression for the object of the preposition (6(a)ii) , recalculates DQ (6(a)iii) and either incorporates the relation in the referring expression or shifts the relation down the *preferred* list (6(a)iv) . 
	</s>
	

	<s id="144">
		 This step ensures that an initial mis-estimation in the word length of a relation doesn’t force its inclusion at the expense of shorter possibilities . 
	</s>
	

	<s id="145">
		 If after incorporating all attributes and relations , the contrast set is still non- empty , the algorithm returns the best expression it can find ( 7 ) . 
	</s>
	

	<s id="146">
		 set generate-ref-exp(Entity , ContrastSet , UsedEntities ) 1 . 
	</s>
	

	<s id="147">
		 IF ContrastSet= [ ] THEN RETURN { Entity.head } 2 . 
	</s>
	

	<s id="148">
		 Calculate CQ , SQ and DQ for each attribute and relation of Entity ( as in Sec 3.1 and 3.4 ) 3 . 
	</s>
	

	<s id="149">
		 Let *preferred* be the list of attributes/ relations sorted in decreasing order of DQs . 
	</s>
	

	<s id="150">
		 FOR each element ( Mod ) of *preferred* DO steps 4 , 5 and 6 4 . 
	</s>
	

	<s id="151">
		 IF ContrastSet = [ ] THEN RETURN RefExp U { Entity.head } 5 . 
	</s>
	

	<s id="152">
		 IF Mod is an Attribute THEN ( a ) LET RefExp = { Mod } U RefExp ( b ) Remove from ContrastSet , any entities Mod rules out 6 . 
	</s>
	

	<s id="153">
		 IF Mod is a Relation [ prepi ei ] THEN ( a ) IF ei E UsedEntities THEN i . 
	</s>
	

	<s id="154">
		 Set DQ = —oo ii . 
	</s>
	

	<s id="155">
		 Move Mod to the end of *preferred* ELSE i. LET ContrastSet2 be the set of non-ei entities that are the objects of prepi relations in members of ContrastSet ii . 
	</s>
	

	<s id="156">
		 LET RE = generate-referring-exp(ei , ContrastSet2 , {ei}UUsedEntities ) iii . 
	</s>
	

	<s id="157">
		 recalculate DQ using length = 2 + length(RE) iv . 
	</s>
	

	<s id="158">
		 IF position in *preferred* is lowered THEN re-sort *preferred* ELSE ( a ) SET Re xp = Re . 
	</s>
	

	<s id="159">
		 . 
	</s>
	

	<s id="160">
		 U { [ prepildeterminerlRE ] } ( o ) Remove from ContrastSet , any entities that Mod rules out 7 . 
	</s>
	

	<s id="161">
		 RETURN RefExp U { Entity.head } An Example Trace : We now trace the algorithm above as it generates a referring expression for d1 in figure 1. call generate-ref-exp(d1,[d2],[]) • step 1 : ContrastSet is not empty • step 2 : DQsmall = —4 , DQgrey = —4 DQ[in b1 ] = 4/3 , DQnear d2 ] = 4/4 • step 3 : *preferred* = [ [ in b1{ [ near d2 ] , small , grey ] head dog attrib [ small , grey ] outside b1 near d1 head bin attrib [ large , steel ] containing d1 near d2 Figure 1 : AVMs for two dogs and a bin • Iteration 1 — mod = [ in b 1 ] – step 6(a)i : ContrastSet2 = [ ] – step 6(a)ii : call generate-ref-exp(b1,[],[d1]) * step 1 : ContrastSet = [ ] return { bin } – step 6(a)iii : DQ[in b1 ] = 4/3 – step 6(a)iva : RefExp = { [ in , the , { bin } ] } – step 6(a)ivo : ContrastSet = [ ] • Iteration 2 — mod = [ near d2 ] – step 4 : ContrastSet = [ ] return { [ in the { bin } ] , dog } The algorithm presented above is designed to return the shortest referring expression that uniquely identifies an entity . 
	</s>
	

	<s id="162">
		 If the scene in figure 1 were cluttered with bins , the algorithm would still refer to d1 as the dog in the bin as there is only one dog that is in a bin . 
	</s>
	

	<s id="163">
		 The user gets no help in locating the bin . 
	</s>
	

	<s id="164">
		 If helping the user locate entities is important to the discourse plan , we need to change step 6(a)(ELSE)i so that the contrast set includes all bins in context , not just bins that are objects of in relations of distractors of d1 . 
	</s>
	

	<s id="165">
		 3.6 Compound Nominals Our analysis so far has assumed that attributes are adjectives . 
	</s>
	

	<s id="166">
		 However , many nominals introduced through relations can also be introduced in compound nominals , for example : 1 . 
	</s>
	

	<s id="167">
		 a church in Paris H a Paris church 2 . 
	</s>
	

	<s id="168">
		 a novel by Archer H an Archer novel 3 . 
	</s>
	

	<s id="169">
		 a company from London H a London company d1 d2 b1 head dog attrib [ small , grey ] in b1 near d2 ~ ~ ~ ~ d1 ~ ~ ~ ~ d2 1 1 ~ ~ b1 ~ ~ ~ ~ This is an important issue for regeneration applications , where the AVMs for entities are constructed from text rather than a semantic knowledge base ( which could be constructed such that such cases are stored in relational form , though possibly with an underspecified relation ) . 
	</s>
	

	<s id="170">
		 We need to augment our algorithm so that it can compare AVMs like : ~ ~head church ~head church ~ in [ head Paris ] and attrib [ Paris ] Formally , the algorithm for calculating SQ and CQ for a nominal attribute a,,,om of entity eo is : FOR each distractor ei of e , DO 1 . 
	</s>
	

	<s id="171">
		 IF a , , , .. is similar to any nominal attribute of ei THEN SQ = SQ + 4 2 . 
	</s>
	

	<s id="172">
		 IF a , , , .. is similar to the head noun of the object of any relation of ei THEN ( a ) SQ = SQ + 4 ( b ) flatten that relation for ei , i.e. , add the attributes of the object of the relation to the attribute list for ei In step 2 , we compare a nominal attribute a,,,om of eo to the head noun of the object of a relation of ei . 
	</s>
	

	<s id="173">
		 If they are similar , it is likely that any attributes of that object might help distinguish eo from ei . 
	</s>
	

	<s id="174">
		 We then add those attributes to the attribute list of ei . 
	</s>
	

	<s id="175">
		 Now , if SQ is non-zero , the nominal attribute a,,,om has bad discriminating power and we set DQ = ^SQ . 
	</s>
	

	<s id="176">
		 If SQ = 0 , then a,,,om has good discriminating power and we set DQ = 4 . 
	</s>
	

	<s id="177">
		 We also extend the algorithm for calculating DQ for a relation [ prep ] ej ] of eo as follows : 1 . 
	</s>
	

	<s id="178">
		 IF any distractor ei has a nominal attribute a , , , .. THEN ( a ) IF a , , , .. is similar to the head of ej THEN i . 
	</s>
	

	<s id="179">
		 Add all attributes of e , to the attribute list and calculate their DQs 2. calculate DQ for the relation as in section 3.4 We can demonstrate how this approach works using entities extracted from the following sentence ( from the Wall Street Journal ) : Also contributing to the firmness in copper , the analyst noted , was a report by Chicago purchasing agents , which precedes the full purchasing agents report that is due out today and gives an indication of what the full report might hold . 
	</s>
	

	<s id="180">
		 Consider generating a referring expression for eo when the distractor is el : head report ~ ~ head agents by ~attrib [ Chicago , ~ purchasing ] ~ ~_ head report e1 attributes [ full , purchasing , agents ] The distractor the full purchasing agents report contains the nominal attribute agents . 
	</s>
	

	<s id="181">
		 To compare report by Chicago purchasing agents with full purchasing agents report , our algorithm flattens the former to Chicago purchasing agents report . 
	</s>
	

	<s id="182">
		 Our algorithm now gives : DQagents = —4 , DQpurchasing = —4 , DQChicago = 4 , DQby Chicagopurchasing agents = 4/4 We thus generate the referring expression the Chicago report . 
	</s>
	

	<s id="183">
		 This approach takes advantage of the flexibility of the relationships that can hold between nouns in a compound : although examples can be devised where removing a nominal causes ungrammaticality , it works well enough empirically . 
	</s>
	

	<s id="184">
		 To generate a referring expression for e1 ( full purchasing agents report ) when the distractor is eo(report by Chicago purchasing agents ) , our algorithm again flattens eo to obtain : DQagents = —4 , DQpurchasing = —4 DQfull=4 The generated referring expression is the full report . 
	</s>
	

	<s id="185">
		 This is identical to the referring expression used in the original text . 
	</s>
	

	<s id="186">
		 4 Evaluation As our algorithm works in open domains , we were able to perform a corpus-based evaluation using the Penn WSJ Treebank 
		<ref citStr="Marcus et al. , 1993" id="10" label="OEPF" position="28662">
			( Marcus et al. , 1993 )
		</ref>
		 . 
	</s>
	

	<s id="187">
		 Our evaluation aimed to reproduce existing referring expressions ( NPs with a definite determiner ) in the Penn Treebank by providing our algorithm as input : 1 . 
	</s>
	

	<s id="188">
		 The first mention NP for that reference . 
	</s>
	

	<s id="189">
		 2. The contrast set of distractor NPs For each referring expression ( NP with a definite determiner ) in the Penn Treebank , we automatically identified its first mention and all its distractors in a four sentence window , as described in § 4.1 . 
	</s>
	

	<s id="190">
		 We then used our program to generate a referring expression for the first mention NP , giving it a contrast- set containing the distractor NPs . 
	</s>
	

	<s id="191">
		 Our evaluation compared this generated description with the original WSJ reference that we had started out with . 
	</s>
	

	<s id="192">
		 Our algorithm was developed using toy examples and counter-examples constructed by hand , and the Penn Treebank was unseen data for this evaluation . 
	</s>
	

	<s id="193">
		 4.1 Identifying Antecedents and Distractors For every definite noun phrase NPo in the Penn Treebank , we shortlisted all the noun phrases NPi in a discourse window of four sentences ( the two ~ ~ ~ ~ e , = preceding sentences , current sentence and the following sentence ) that had a head noun identical to or a WordNet synonym of the head noun of NPo . 
	</s>
	

	<s id="194">
		 We compared the set of attributes and relations for each shortlisted NPZ that preceded NPo in the discourse window with that of NPo . 
	</s>
	

	<s id="195">
		 If the attributes and relations set of NPZ was a superset of that of NPo , we assumed that NPo referred to NPZ and added NPZ to an antecedent set . 
	</s>
	

	<s id="196">
		 We added all other NPZ to the contrast set of distractors . 
	</s>
	

	<s id="197">
		 Similarly , we excluded any noun phrase NPZ that appeared in the discourse after NPo whose attributes and relations set was a subset of NPo’s and added the remaining NPZ to the contrast set . 
	</s>
	

	<s id="198">
		 We then selected the longest noun phrase in the antecedent set to be the antecedent that we would try and generate a referring expression from . 
	</s>
	

	<s id="199">
		 The table below gives some examples of distractors that our program found using WordNet synonyms to compare head nouns : Entity Distractors first half-free Soviet vote military construction bill steep fall in currency permanent insurance fair elections in the GDR fiscal measure drop in market stock death benefit coverage 4.2 Results There were 146 instances of definite descriptions in the WSJ where the following conditions ( that ensure that the referring expression generation task is nontrivial ) were satisfied : 1 . 
	</s>
	

	<s id="200">
		 The definite NP ( referring expression ) contained at least one attribute or relation . 
	</s>
	

	<s id="201">
		 2. An antecedent was found for the definite NP . 
	</s>
	

	<s id="202">
		 3. There was at least one distractor NP in the discourse window . 
	</s>
	

	<s id="203">
		 In 81.5 % of these cases , our program returned a referring expression that was identical to the one used in the WSJ . 
	</s>
	

	<s id="204">
		 This is a surprisingly high accuracy , considering that there is a fair amount of variability in the way human writers use referring expressions . 
	</s>
	

	<s id="205">
		 For comparison , the baseline of reproducing the antecedent NP performed at 48%2 . 
	</s>
	

	<s id="206">
		 Some errors were due to non-recognition of multiword expessions in the antecedent ( for example , our program generated care product from personal care product ) . 
	</s>
	

	<s id="207">
		 In many of the remaining error cases , it was difficult to decide whether what our program generated was acceptable or wrong . 
	</s>
	

	<s id="208">
		 For example , the WSJ contained the referring expression the one-day limit , where the automatically detected antecedent was the maximum one-day limit for the 2We are only evaluating content selection ( the nouns and pre- and post-modifiers ) and ignore determiner choice . 
	</s>
	

	<s id="209">
		 S&amp;P 500 stock-index futures contract and the automatically detected contrast set was : { the five-point opening limit for the contract , the 12-point limit , the 30-point limit , the in- termediate limit of 20 points } Our program generated the maximum limit , where the WSJ writer preferred the one-day limit . 
	</s>
	

	<s id="210">
		 5 Further Issues 5.1 Reference Modifying Attributes The analysis thus far has assumed that all attributes modify the referent rather than the reference to the referent . 
	</s>
	

	<s id="211">
		 However , for example , if e 1 is an alleged murderer , the attribute alleged modifies the reference murderer rather than the referent e 1 and referring to e 1 as the murderer would be factually incorrect . 
	</s>
	

	<s id="212">
		 Logically e 1 could be represented as ( alleged1 ( murderer1 ) ) ( x ) , rather than alleged1 ( x ) n murderer1 ( x ) . 
	</s>
	

	<s id="213">
		 This is no longer first-order , and presents new difficulties for the traditional formalisation of the reference generation problem . 
	</s>
	

	<s id="214">
		 One ( inelegant ) solution would be to introduce a new predicate allegedMurderer1 ( x ) . 
	</s>
	

	<s id="215">
		 A working approach in our framework would be to add a large positive weight to the DQs of reference modifying attributes , thus forcing them to be selected in the referring expression . 
	</s>
	

	<s id="216">
		 5.2 Discourse Context and Salience The incremental algorithm assumes the availability of a contrast set and does not provide an algorithm for constructing and updating it . 
	</s>
	

	<s id="217">
		 The contrast set , in general , needs to take context into account . 
	</s>
	

	<s id="218">
		 
		<ref citStr="Krahmer and Theune ( 2002 )" id="11" label="CEPF" position="33983">
			Krahmer and Theune ( 2002 )
		</ref>
		 propose an extension to the IA which treats the context set as a combination of a discourse domain and a salience function . 
	</s>
	

	<s id="219">
		 The black dog would then refer to the most salient entity in the discourse domain that is both black and a dog . 
	</s>
	

	<s id="220">
		 Incorporating salience into our algorithm is straightforward . 
	</s>
	

	<s id="221">
		 As described earlier , we compute the quotients SQ and CQ for each attribute or relation by adding an amount w E 14,2 , 11 to the relevant quotient based on a comparison with the attributes and relations of each distractor . 
	</s>
	

	<s id="222">
		 We can incorporate salience by weighting w with the salience of the distractor whose attribute or relation we are considering . 
	</s>
	

	<s id="223">
		 This will result in attributes and relations with high discriminating power with regard to more salient distractors getting selected first in the incremental process . 
	</s>
	

	<s id="224">
		 5.3 Discourse Plans In many situations , attributes and relations serve different discourse functions . 
	</s>
	

	<s id="225">
		 For example , attributes might be used to help the hearer identify an entity while relations might serve to help locate the entity . 
	</s>
	

	<s id="226">
		 This needs to be taken into account when generating a referring expression . 
	</s>
	

	<s id="227">
		 If we were generating instructions for using a machine , we might want to include both attributes and relations ; so to instruct the user to switch on the power , we might say switch on the red button on the top-left corner . 
	</s>
	

	<s id="228">
		 This would help the user locate the switch ( on the top-left corner ) and identify it ( red ) . 
	</s>
	

	<s id="229">
		 If we were helping a chef find the salt in a kitchen , we might want to use only relations because the chef knows what salt looks like . 
	</s>
	

	<s id="230">
		 The salt behind the corn flakes on the shelf above the fridge is in this context preferable to the white powder . 
	</s>
	

	<s id="231">
		 If the discourse plan that controls generation requires our algorithm to preferentially select relations or attributes , it can add a positive amount a to their DQs . 
	</s>
	

	<s id="232">
		 Then , the resultant formula is DQ = ( CQ — SQ)/length + a , where length = 1 for attributes and by default a = 0 for both relations and attributes . 
	</s>
	

	<s id="233">
		 6 Conclusions and Future Work We have described an algorithm for generating referring expressions that can be used in any domain . 
	</s>
	

	<s id="234">
		 Our algorithm selects attributes and relations that are distinctive in context . 
	</s>
	

	<s id="235">
		 It does not rely on the availability of an adjective classification scheme and uses WordNet antonym and synonym lists instead . 
	</s>
	

	<s id="236">
		 It is also , as far as we know , the first algorithm that allows for the incremental incorporation of relations and the first that handles nominals . 
	</s>
	

	<s id="237">
		 In a novel evaluation , our algorithm successfully generates identical referring expressions to those in the Penn WSJ Treebank in over 80 % of cases . 
	</s>
	

	<s id="238">
		 In future work , we plan to use this algorithm as part of a system for generation from a database of user opinions on products which has been automatically extracted from newsgroups and similar text . 
	</s>
	

	<s id="239">
		 This is midway between regeneration and the classical task of generating from a knowledge base because , while the database itself provides structure , many of the field values are strings corresponding to phrases used in the original text . 
	</s>
	

	<s id="240">
		 Thus , our lexicalised approach is directly applicable to this task . 
	</s>
	

	<s id="241">
		 7 Acknowledgements Thanks are due to Kees van Deemter and three anonymous ACL reviewers for useful feedback on prior versions of this paper . 
	</s>
	

	<s id="242">
		 This document was generated partly in the context of the Deep Thought project , funded under the Thematic Programme User-friendly Information Society of the 5th Framework Programme of the European Community ( Contract N IST-2001-37836 ) References Robert Dale and Nicholas Haddock . 
	</s>
	

	<s id="243">
		 1991. Generating referring expressions involving relations . 
	</s>
	

	<s id="244">
		 In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics ( EACL’91 ) , pages 161–166 , Berlin , Germany . 
	</s>
	

	<s id="245">
		 Robert Dale and Ehud Reiter . 
	</s>
	

	<s id="246">
		 1995. Computational interpretations of the Gricean maxims in the generation of referring expressions . 
	</s>
	

	<s id="247">
		 Cognitive Science , 19:233–263 . 
	</s>
	

	<s id="248">
		 Helmut Horacek . 
	</s>
	

	<s id="249">
		 2003. A best-first search algorithm for generating referring expressions . 
	</s>
	

	<s id="250">
		 In Proceedings of the 11th Conference of the European Chapter of the Association for Computational Linguistics ( EACL’03 ) , pages 103–106 , Budapest , Hungary . 
	</s>
	

	<s id="251">
		 Emiel Krahmer and Mari¨et Theune . 
	</s>
	

	<s id="252">
		 2002. Efficient context-sensitive generation of referring expressions . 
	</s>
	

	<s id="253">
		 In Kees van Deemter and Rodger Kibble , editors , Information Sharing : Givenness and Newness in Language Processing , pages 223– 264 . 
	</s>
	

	<s id="254">
		 CSLI Publications , Stanford,California . 
	</s>
	

	<s id="255">
		 Emiel Krahmer , Sebastiaan van Erk , and Andr´e Verleg . 
	</s>
	

	<s id="256">
		 2003. Graph-based generation of referring expressions . 
	</s>
	

	<s id="257">
		 Computational Linguistics , 29(1):53–72 . 
	</s>
	

	<s id="258">
		 Mitchell Marcus , Beatrice Santorini , and Mary Marcinkiewicz . 
	</s>
	

	<s id="259">
		 1993. Building a large natural language corpus of English : The Penn Treebank . 
	</s>
	

	<s id="260">
		 Computational Linguistics , 19:313–330 . 
	</s>
	

	<s id="261">
		 George A. Miller , Richard Beckwith , Christiane D. Fellbaum , Derek Gross , and Katherine Miller . 
	</s>
	

	<s id="262">
		 1993. Five Papers on WordNet . 
	</s>
	

	<s id="263">
		 Technical report , Princeton University , Princeton , N.J. Ehud Reiter . 
	</s>
	

	<s id="264">
		 1990. The computational complexity of avoiding conversational implicatures . 
	</s>
	

	<s id="265">
		 In Proceedings of the 28th Annual Meeting of Association for Computational Linguistics ( ACL’90 ) , pages 97–104 , Pittsburgh , Pennsylvania . 
	</s>
	

	<s id="266">
		 Ehud Reiter and Robert Dale . 
	</s>
	

	<s id="267">
		 1992. A fast algorithm for the generation of referring expressions . 
	</s>
	

	<s id="268">
		 In Proceedings of the 14th International Conference on Computational Linguistics ( COLING’92 ) , pages 232–238 , Nantes , France . 
	</s>
	

	<s id="269">
		 Kees van Deemter . 
	</s>
	

	<s id="270">
		 2000. Generating vague descriptions . 
	</s>
	

	<s id="271">
		 In Proceedings of the 1 st International Conference on Natural Language Generation ( INLG’00 ) , pages 179–185 , Mitzpe Ramon , Israel . 
	</s>
	

	<s id="272">
		 Kees van Deemter . 
	</s>
	

	<s id="273">
		 2002. Generating referring expressions : Boolean extensions of the incremental algorithm . 
	</s>
	

	<s id="274">
		 Computational Linguistics , 28(1):37– 52. 
	</s>
	


</acldoc>
